<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vågsimulator - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.1);
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.4);
      }

      body {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
      }

      #root {
        width: 100vw;
        height: 100vh;
      }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link active">Fysik 2</a></li>
                <li><a href="om.html" class="nav-link">Om</a></li>
                <li><a href="kontakt.html" class="nav-link">Kontakt</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
const { useState, useRef, useEffect } = React;

// Types (using JSDoc comments for type hints)
/** @typedef {'single' | 'double' | 'planar' | 'doppler' | 'refraction' | 'diffraction' | 'diffraction-double'} SimulationMode */
/** @typedef {{ x: number; y: number }} Point */
/** @typedef {{ x: number; y: number; emitTime: number }} WaveFront */

const WaveSimulator = () => {
  // --- State ---
  const [isPlaying, setIsPlaying] = useState(true);
  const [viewMode, setViewMode] = useState('2D');
  const [mode, setMode] = useState('single');
  const [showNodalLines, setShowNodalLines] = useState(false);
  const [showMaximaLines, setShowMaximaLines] = useState(false);
  const [showRefractionAngles, setShowRefractionAngles] = useState(false);

  // Physics Parameters
  const [frequency, setFrequency] = useState(2); // Hz
  const [separation, setSeparation] = useState(150); // pixels
  const [sourceSpeed, setSourceSpeed] = useState(1.5); // Multiplier
  const [waveSpeedParam, setWaveSpeedParam] = useState(100); // pixels/s
  const [slitWidth, setSlitWidth] = useState(50); // pixels

  // Refs for animation
  const canvasRef = useRef(null);
  const requestRef = useRef();
  const timeRef = useRef(0);
  const wavefrontsRef = useRef([]);
  const lastEmitTimeRef = useRef(0);

  // Refs for Camera Interaction
  const cameraAngleRef = useRef({ h: Math.PI / 4, v: Math.PI / 4 }); // Azimuth (h), Elevation (v)
  const isDraggingRef = useRef(false);
  const lastMousePosRef = useRef({ x: 0, y: 0 });

  // Configuration constants
  const CANVAS_WIDTH = 800;
  const CANVAS_HEIGHT = 600;

  // Reset time when switching major modes to prevent jumps
  useEffect(() => {
    wavefrontsRef.current = [];
    lastEmitTimeRef.current = timeRef.current;
  }, [mode]);

  // --- Physics & Math Helpers ---

  const getSources = (t) => {
    const centerX = CANVAS_WIDTH / 2;
    const centerY = CANVAS_HEIGHT / 2;

    if (mode === 'doppler') {
      // Moving source for Doppler (Linear motion loop)
      // Wave speed is 100 px/s. Source moves at 60 px/s (subsonic) to show doppler effect clearly.

      const cycleDur = 6; // seconds for one pass
      const progress = (t % cycleDur) / cycleDur;

      // Distance to travel: 6s * 60px/s = 360px
      const range = 360;

      const x = (centerX - range/2) + progress * range;
      return [{ x, y: centerY }];
    }

    if (mode === 'double') {
      return [
        { x: centerX - separation / 2, y: centerY },
        { x: centerX + separation / 2, y: centerY },
      ];
    }

    if (mode === 'single') {
        return [{ x: centerX, y: centerY }];
    }

    // Planar/Refraction/Diffraction waves don't have a point source in the same way
    return [];
  };

  const calculateInterferenceLines = (wavelength, separation, type) => {
      const curves = [];
      const phaseOffset = type === 'nodal' ? 0.5 : 0;

      // Nodal condition: |r1 - r2| = (n + 0.5) * lambda
      // Maxima condition: |r1 - r2| = n * lambda

      // Max path diff is separation d.
      // So (n + offset) * lambda < separation

      const maxN = Math.floor(separation / wavelength - phaseOffset - 0.01);
      const cx = CANVAS_WIDTH / 2;
      const cy = CANVAS_HEIGHT / 2;
      const yRange = CANVAS_HEIGHT / 2 + 50;

      // We iterate n to find the hyperbolas
      for (let n = 0; n <= maxN; n++) {
          const k = n + phaseOffset;
          const delta = k * wavelength; // Path difference

          if (delta === 0) {
              // Center line for n=0 Maxima
              const pts = [];
              for (let y = -yRange; y <= yRange; y += 10) {
                  pts.push({ x: cx, y: cy + y });
              }
              curves.push(pts);
              continue;
          }

          // Hyperbola parameters: x^2/a^2 - y^2/b^2 = 1
          // 2a = delta => a = delta / 2
          const a = delta / 2;

          // c = separation / 2 (focal distance from center)
          const c = separation / 2;

          if (a >= c) continue;

          const b = Math.sqrt(c * c - a * a);

          const ptsRight = [];
          const ptsLeft = [];

          // Generate points for the hyperbola
          for (let y = -yRange; y <= yRange; y += 10) {
              // x = a * sqrt(1 + y^2/b^2)
              const xVal = a * Math.sqrt(1 + (y * y) / (b * b));

              ptsRight.push({ x: cx + xVal, y: cy + y });
              ptsLeft.push({ x: cx - xVal, y: cy + y });
          }

          curves.push(ptsRight);
          curves.push(ptsLeft);
      }
      return curves;
  };

  // --- Interaction Handlers ---

  const handleMouseDown = (e) => {
    if (viewMode === '3D') {
        isDraggingRef.current = true;
        lastMousePosRef.current = { x: e.clientX, y: e.clientY };
    }
  };

  const handleMouseMove = (e) => {
    if (viewMode === '3D' && isDraggingRef.current) {
        const dx = e.clientX - lastMousePosRef.current.x;
        const dy = e.clientY - lastMousePosRef.current.y;

        const sensitivity = 0.01;

        // Update angles
        // h: Azimuth (rotation around vertical axis)
        // v: Elevation (angle from horizon)

        let newH = cameraAngleRef.current.h + dx * sensitivity;
        let newV = cameraAngleRef.current.v - dy * sensitivity;

        // Clamp elevation to avoid flipping upside down or going underground
        // 0.1 rad (~5 deg) to PI/2 (90 deg, top down)
        newV = Math.max(0.1, Math.min(Math.PI / 2, newV));

        cameraAngleRef.current = { h: newH, v: newV };
        lastMousePosRef.current = { x: e.clientX, y: e.clientY };
    }
  };

  const handleMouseUp = () => {
    isDraggingRef.current = false;
  };

  const handleMouseLeave = () => {
    isDraggingRef.current = false;
  }

  // --- Renderers ---

  const draw2D = (ctx, t, sources) => {
    const wavelength = waveSpeedParam / frequency;

    // Background
    ctx.fillStyle = '#001a33';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    if (mode === 'doppler') {
      // Doppler Visualization: Draw expanding wavefronts

      const currentWavefronts = wavefrontsRef.current;

      for (const wf of currentWavefronts) {
        const age = t - wf.emitTime;
        if (age < 0) continue;
        const radius = age * waveSpeedParam;

        // Fade out as it gets large
        const alpha = Math.max(0, 1 - radius / 600);
        ctx.lineWidth = 3;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;

        ctx.beginPath();
        ctx.arc(wf.x, wf.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Draw source
      ctx.fillStyle = '#ffcc00';
      for (const src of sources) {
        ctx.beginPath();
        ctx.arc(src.x, src.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }

    } else {
      // Interference / Standard Wave Field / Planar / Refraction / Diffraction
      // Using ImageData for performance in 2D heatmap mode
      const imgData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      const data = imgData.data;

      const k = (2 * Math.PI) / wavelength;
      const omega = 2 * Math.PI * frequency;

      const src1 = sources[0];
      const src2 = sources[1]; // may be undefined

      // Refraction constants
      // Horizontal boundary at middle of height
      const boundaryY = CANVAS_HEIGHT / 2;
      const incidentAngle = Math.PI / 6; // 30 degrees w.r.t the normal (Vertical Y-axis)
      const n1 = 1.0;
      const n2 = 2.0; // Index of refraction (slower in medium 2)
      const v1 = waveSpeedParam;
      const v2 = v1 / n2;

      // Snell's law
      const sinTheta2 = (v2 / v1) * Math.sin(incidentAngle);
      const theta2 = Math.asin(sinTheta2);

      const k1 = omega / v1;
      const k2 = omega / v2;

      const k1x = k1 * Math.sin(incidentAngle);
      const k1y = k1 * Math.cos(incidentAngle);

      const k2x = k2 * Math.sin(theta2);
      const k2y = k2 * Math.cos(theta2);

      const phaseOffset = (k1y - k2y) * boundaryY;

      // Diffraction Setup
      let huygensSources = [];
      const cx = CANVAS_WIDTH / 2;
      const numPointsPerSlit = Math.max(3, Math.floor(slitWidth / 4));

      if (mode === 'diffraction') {
          // Single slit centered at cx
          for (let i = 0; i < numPointsPerSlit; i++) {
              const xPos = cx - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
              huygensSources.push(xPos);
          }
      } else if (mode === 'diffraction-double') {
          // Left Slit: centered at cx - separation/2
          const centerLeft = cx - separation / 2;
          for (let i = 0; i < numPointsPerSlit; i++) {
              const xPos = centerLeft - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
              huygensSources.push(xPos);
          }
          // Right Slit: centered at cx + separation/2
          const centerRight = cx + separation / 2;
          for (let i = 0; i < numPointsPerSlit; i++) {
              const xPos = centerRight - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
              huygensSources.push(xPos);
          }
      }

      // Step 2 pixels for performance
      for (let y = 0; y < CANVAS_HEIGHT; y += 2) {
        for (let x = 0; x < CANVAS_WIDTH; x += 2) {
           let z = 0;

           if (mode === 'planar') {
               // Planar wave moving right
               z = Math.sin(k * x - omega * t);
           } else if (mode === 'refraction') {
               if (y < boundaryY) {
                   // Medium 1 (Top)
                   z = Math.sin(k1x * x + k1y * y - omega * t);
               } else {
                   // Medium 2 (Bottom)
                   z = Math.sin(k2x * x + k2y * y - omega * t + phaseOffset);
               }
           } else if (mode === 'diffraction' || mode === 'diffraction-double') {
               if (y < boundaryY) {
                   // Planar wave coming from top
                   z = Math.sin(k * y - omega * t);
               } else {
                   // Huygens Principle: Sum of point sources from the slit
                   let sum = 0;
                   // Phase match at boundary: Incident wave at y=boundaryY has phase k*boundaryY - wt
                   const incidentPhaseAtBoundary = k * boundaryY;

                   for (const hs of huygensSources) {
                       const dist = Math.sqrt((x - hs)**2 + (y - boundaryY)**2);
                       // Each source emits spherical wave.
                       sum += Math.sin(k * dist - omega * t + incidentPhaseAtBoundary);
                   }

                   // Normalize amplitude
                   z = sum / Math.sqrt(huygensSources.length * (mode === 'diffraction-double' ? 1 : 2));
               }
           } else {
               // Source 1
               if (src1) {
                   const d1 = Math.sqrt((x - src1.x)**2 + (y - src1.y)**2);
                   z += Math.sin(k * d1 - omega * t);
               }
               // Source 2
               if (src2) {
                   const d2 = Math.sqrt((x - src2.x)**2 + (y - src2.y)**2);
                   z += Math.sin(k * d2 - omega * t);
               }
           }

           // Normalize z to 0-1 range for coloring
           const maxAmp = (mode === 'double' || mode === 'diffraction-double') ? 2 : 1;
           let val = (z + maxAmp) / (maxAmp * 2);

           if (val < 0) val = 0;
           if (val > 1) val = 1;

           // Blue gradient with white peaks
           const r = val * 200;
           const g = 50 + val * 205;
           const b = 100 + val * 155;

           // Fill 2x2 block
           const idx = (y * CANVAS_WIDTH + x) * 4;
           data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
           data[idx+4] = r; data[idx+5] = g; data[idx+6] = b; data[idx+7] = 255;

           const idxBelow = ((y + 1) * CANVAS_WIDTH + x) * 4;
           if (idxBelow < data.length) {
              data[idxBelow] = r; data[idxBelow+1] = g; data[idxBelow+2] = b; data[idxBelow+3] = 255;
              data[idxBelow+4] = r; data[idxBelow+5] = g; data[idxBelow+6] = b; data[idxBelow+7] = 255;
           }
        }
      }
      ctx.putImageData(imgData, 0, 0);

      // Overlays
      if (mode === 'refraction') {
          // Draw boundary line (Horizontal)
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.setLineDash([5, 5]);
          ctx.moveTo(0, boundaryY);
          ctx.lineTo(CANVAS_WIDTH, boundaryY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Text Labels
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.font = '14px Arial';
          ctx.fillText("Djupt vatten (v)", 20, boundaryY - 10);
          ctx.fillText("Grunt vatten (v/2)", 20, boundaryY + 20);

          if (showRefractionAngles) {
              const rayLen = 150;
              const cx = CANVAS_WIDTH / 2;
              const cy = boundaryY;

              // Ray Geometry
              // Incident Ray (From Top-Left)
              const startX = cx - rayLen * Math.sin(incidentAngle);
              const startY = cy - rayLen * Math.cos(incidentAngle);

              // Refracted Ray (To Bottom-Right)
              const endX = cx + rayLen * Math.sin(theta2);
              const endY = cy + rayLen * Math.cos(theta2);

              // Draw Rays
              ctx.lineWidth = 3;
              ctx.strokeStyle = 'rgba(255, 230, 0, 0.9)'; // Yellow
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.lineTo(cx, cy);
              ctx.lineTo(endX, endY);
              ctx.stroke();

              // Draw Normal Line
              ctx.lineWidth = 1;
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
              ctx.setLineDash([4, 4]);
              ctx.beginPath();
              ctx.moveTo(cx, cy - rayLen);
              ctx.lineTo(cx, cy + rayLen);
              ctx.stroke();
              ctx.setLineDash([]);

              // Draw Angle Arcs
              const arcRadius = 40;

              // Incident Angle Arc (From Normal-Up to Incident Ray)
              // Normal Up is -90 deg (-PI/2). Incident Ray comes from -90 - theta.
              ctx.beginPath();
              ctx.strokeStyle = '#fff';
              ctx.arc(cx, cy, arcRadius, -Math.PI / 2 - incidentAngle, -Math.PI / 2);
              ctx.stroke();

              // Refracted Angle Arc (From Refracted Ray to Normal-Down)
              // Normal Down is 90 deg (PI/2). Refracted Ray is at 90 - theta.
              ctx.beginPath();
              ctx.arc(cx, cy, arcRadius, Math.PI / 2 - theta2, Math.PI / 2);
              ctx.stroke();

              // Labels
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 16px Arial';
              const deg1 = Math.round(incidentAngle * 180 / Math.PI);
              const deg2 = Math.round(theta2 * 180 / Math.PI);
              ctx.fillText(`${deg1}°`, cx - 35, cy - 50);
              ctx.fillText(`${deg2}°`, cx + 20, cy + 50);
          }
      }

      if (mode === 'diffraction' || mode === 'diffraction-double') {
           // Draw Barrier
           ctx.fillStyle = '#000';
           const cx = CANVAS_WIDTH / 2;

           if (mode === 'diffraction') {
                // Left part
                ctx.fillRect(0, boundaryY - 2, cx - slitWidth / 2, 4);
                // Right part
                ctx.fillRect(cx + slitWidth / 2, boundaryY - 2, CANVAS_WIDTH - (cx + slitWidth / 2), 4);
           } else {
                // Double Slit Barriers
                // Left Wall: 0 to (cx - sep/2 - w/2)
                ctx.fillRect(0, boundaryY - 2, (cx - separation/2) - slitWidth/2, 4);
                // Center Wall: (cx - sep/2 + w/2) to (cx + sep/2 - w/2)
                const centerStart = (cx - separation/2) + slitWidth/2;
                const centerEnd = (cx + separation/2) - slitWidth/2;
                if (centerEnd > centerStart) {
                    ctx.fillRect(centerStart, boundaryY - 2, centerEnd - centerStart, 4);
                }
                // Right Wall: (cx + sep/2 + w/2) to End
                const rightStart = (cx + separation/2) + slitWidth/2;
                ctx.fillRect(rightStart, boundaryY - 2, CANVAS_WIDTH - rightStart, 4);
           }
      }

      const drawLines = (type, color) => {
        const lines = calculateInterferenceLines(wavelength, separation, type);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);

        lines.forEach(curve => {
            if (curve.length < 2) return;

            if (mode === 'diffraction-double') {
                let started = false;
                ctx.beginPath();
                for (let i = 0; i < curve.length; i++) {
                    if (curve[i].y > boundaryY) {
                        if (!started) {
                            ctx.moveTo(curve[i].x, curve[i].y);
                            started = true;
                        } else {
                            ctx.lineTo(curve[i].x, curve[i].y);
                        }
                    }
                }
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.moveTo(curve[0].x, curve[0].y);
                for (let i = 1; i < curve.length; i++) {
                    ctx.lineTo(curve[i].x, curve[i].y);
                }
                ctx.stroke();
            }
        });
        ctx.setLineDash([]);
      };

      if (mode === 'double' || mode === 'diffraction-double') {
        if (showNodalLines) drawLines('nodal', 'rgba(255, 50, 50, 0.9)');
        if (showMaximaLines) drawLines('maxima', 'rgba(50, 255, 50, 0.9)');
      }

      if (mode !== 'planar' && mode !== 'refraction' && mode !== 'diffraction' && mode !== 'diffraction-double') {
          ctx.fillStyle = '#ffcc00';
          for (const src of sources) {
            ctx.beginPath();
            ctx.arc(src.x, src.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
      }
    }
  };

  const draw3D = (ctx, t, sources) => {
    const cx = CANVAS_WIDTH / 2;
    const cy = CANVAS_HEIGHT / 2;

    // Background
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Get Camera Rotation
    const { h, v } = cameraAngleRef.current;
    const cosH = Math.cos(h);
    const sinH = Math.sin(h);
    const cosV = Math.cos(v);
    const sinV = Math.sin(v);

    // Projection Function
    const project = (x, y, z) => {
        const dx = x - cx;
        const dy = y - cy;

        // Rotate Azimuth
        const xRot = dx * cosH - dy * sinH;
        const yRot = dx * sinH + dy * cosH;

        // Rotate Elevation & Project
        const px = cx + xRot;
        const py = cy + yRot * sinV - z * 3 * cosV;

        return { x: px, y: py, depth: yRot }; // Return depth for sorting
    };

    // --- Doppler 3D Visualization (Simple Rings) ---
    if (mode === 'doppler') {
       const currentWavefronts = wavefrontsRef.current;
       ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
       ctx.lineWidth = 1;

       for (const wf of currentWavefronts) {
        const age = t - wf.emitTime;
        if (age < 0) continue;
        const radius = age * waveSpeedParam;

        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.2) {
            const wx = wf.x + radius * Math.cos(a);
            const wy = wf.y + radius * Math.sin(a);
            const { x: px, y: py } = project(wx, wy, 0);

            if (a === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
       }

       // Draw source
       ctx.fillStyle = '#ffcc00';
       for (const src of sources) {
          const { x: px, y: py } = project(src.x, src.y, 0);
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fill();
       }
       return;
    }

    // --- Standard Wave Surface (Filled Mesh) ---
    const wavelength = waveSpeedParam / frequency;
    const k = (2 * Math.PI) / wavelength;
    const omega = 2 * Math.PI * frequency;

    // Refraction constants for 3D
    const boundaryY = CANVAS_HEIGHT / 2;
    const incidentAngle = Math.PI / 6;
    const n2 = 2.0;
    const v1 = waveSpeedParam;
    const v2 = v1 / n2;
    const sinTheta2 = (v2 / v1) * Math.sin(incidentAngle);
    const theta2 = Math.asin(sinTheta2);
    const k1 = omega / v1;
    const k2 = omega / v2;

    // Normal is Y axis
    const k1x = k1 * Math.sin(incidentAngle);
    const k1y = k1 * Math.cos(incidentAngle);
    const k2x = k2 * Math.sin(theta2);
    const k2y = k2 * Math.cos(theta2);
    const phaseOffset = (k1y - k2y) * boundaryY;

    // Diffraction Setup for 3D
    let huygensSources = [];
    const numPointsPerSlit = Math.max(3, Math.floor(slitWidth / 4));

    if (mode === 'diffraction') {
        for (let i = 0; i < numPointsPerSlit; i++) {
            const xPos = cx - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
            huygensSources.push(xPos);
        }
    } else if (mode === 'diffraction-double') {
          // Left Slit
          const centerLeft = cx - separation / 2;
          for (let i = 0; i < numPointsPerSlit; i++) {
              const xPos = centerLeft - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
              huygensSources.push(xPos);
          }
          // Right Slit
          const centerRight = cx + separation / 2;
          for (let i = 0; i < numPointsPerSlit; i++) {
              const xPos = centerRight - slitWidth / 2 + (slitWidth * (i + 0.5)) / numPointsPerSlit;
              huygensSources.push(xPos);
          }
    }
    const incidentPhaseAtBoundary = k * boundaryY;


    // Increased resolution for smoother surface (150x150)
    const cols = 150;
    const rows = 150;
    const stepX = CANVAS_WIDTH / cols;
    const stepY = CANVAS_HEIGHT / rows;

    // 1. Calculate vertices and heights
    const vertices = [];

    for (let r = 0; r <= rows; r++) {
        for (let c = 0; c <= cols; c++) {
            const x = c * stepX;
            const y = r * stepY;
            let z = 0;

            if (mode === 'planar') {
                z = Math.sin(k * x - omega * t) * 5;
            } else if (mode === 'refraction') {
                if (y < boundaryY) {
                   z = Math.sin(k1x * x + k1y * y - omega * t) * 5;
                } else {
                   z = Math.sin(k2x * x + k2y * y - omega * t + phaseOffset) * 5;
                }
            } else if (mode === 'diffraction' || mode === 'diffraction-double') {
                if (y < boundaryY) {
                    z = Math.sin(k * y - omega * t) * 5;
                } else {
                    let sum = 0;
                    for (const hs of huygensSources) {
                        const dist = Math.sqrt((x - hs)**2 + (y - boundaryY)**2);
                        sum += Math.sin(k * dist - omega * t + incidentPhaseAtBoundary);
                    }
                    const numSrc = mode === 'diffraction-double' ? huygensSources.length / 2 : huygensSources.length;
                    z = (sum / Math.sqrt(numSrc * 2)) * 5;
                }
            } else {
                for (const src of sources) {
                    const dist = Math.sqrt((x - src.x)**2 + (y - src.y)**2);
                    // Attenuation for visual fade at edges
                    const d = Math.max(0, 1000 - dist)/1000;
                    z += Math.sin(k * dist - omega * t) * 5 * d;
                }
            }

            const p = project(x, y, z);
            vertices.push({ x, y, z, px: p.x, py: p.y, depth: p.depth });
        }
    }

    // 2. Create Quads (Faces)
    const quads = [];

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const idx = r * (cols + 1) + c;
            const p1 = idx;
            const p2 = idx + 1;
            const p3 = idx + (cols + 1) + 1;
            const p4 = idx + (cols + 1);

            const v1 = vertices[p1];
            const v2 = vertices[p2];
            const v3 = vertices[p3];
            const v4 = vertices[p4];

            // Use average depth for Painter's Algorithm sorting
            const avgDepth = (v1.depth + v2.depth + v3.depth + v4.depth) / 4;
            const avgZ = (v1.z + v2.z + v3.z + v4.z) / 4;

            quads.push({
                p1, p2, p3, p4,
                avgDepth,
                avgZ,
                centerX: (v1.x + v2.x + v3.x + v4.x)/4,
                centerY: (v1.y + v2.y + v3.y + v4.y)/4
            });
        }
    }

    // 3. Sort Quads (Painter's Algorithm)
    quads.sort((a, b) => a.avgDepth - b.avgDepth);

    // 4. Draw Quads
    const maxAmp = (mode === 'double' || mode === 'diffraction-double') ? 10 : 5;

    for (const q of quads) {
        const v1 = vertices[q.p1];
        const v2 = vertices[q.p2];
        const v3 = vertices[q.p3];
        const v4 = vertices[q.p4];

        // Color Logic
        // Normalize Z: -max to +max map to 0-1
        let val = (q.avgZ + maxAmp) / (maxAmp * 2);
        if (val < 0) val = 0; if (val > 1) val = 1;

        // Enhanced Gradient: Dark Blue -> Blue -> White
        const red = val * 230;
        const green = val * 240;
        const blue = 80 + val * 175;

        const fillStyle = `rgb(${red}, ${green}, ${blue})`;

        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = fillStyle; // stroke with same color to fill gaps
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(v1.px, v1.py);
        ctx.lineTo(v2.px, v2.py);
        ctx.lineTo(v3.px, v3.py);
        ctx.lineTo(v4.px, v4.py);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    // Draw boundary line in 3D
    if (mode === 'refraction') {
        const pStart = project(0, boundaryY, 0);
        const pEnd = project(CANVAS_WIDTH, boundaryY, 0);
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.moveTo(pStart.x, pStart.y);
        ctx.lineTo(pEnd.x, pEnd.y);
        ctx.stroke();
        ctx.setLineDash([]);

        if (showRefractionAngles) {
            const rayLen = 150;
            const cx = CANVAS_WIDTH / 2;
            const cy = boundaryY;
            const zOff = 10; // Draw slightly above waves

            // Calculate 3D points
            const startX = cx - rayLen * Math.sin(incidentAngle);
            const startY = cy - rayLen * Math.cos(incidentAngle);
            const endX = cx + rayLen * Math.sin(theta2);
            const endY = cy + rayLen * Math.cos(theta2);

            const pRayStart = project(startX, startY, zOff);
            const pCenter = project(cx, cy, zOff);
            const pRayEnd = project(endX, endY, zOff);
            const pNormStart = project(cx, cy - rayLen, zOff);
            const pNormEnd = project(cx, cy + rayLen, zOff);

            // Rays
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgba(255, 230, 0, 0.9)';
            ctx.beginPath();
            ctx.moveTo(pRayStart.x, pRayStart.y);
            ctx.lineTo(pCenter.x, pCenter.y);
            ctx.lineTo(pRayEnd.x, pRayEnd.y);
            ctx.stroke();

            // Normal
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(pNormStart.x, pNormStart.y);
            ctx.lineTo(pNormEnd.x, pNormEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    if (mode === 'diffraction' || mode === 'diffraction-double') {
        // Helper to draw plate
        const drawPlate = (xStart, xEnd) => {
             const p1 = project(xStart, boundaryY - 5, 5);
             const p2 = project(xEnd, boundaryY - 5, 5);
             const p3 = project(xEnd, boundaryY + 5, 5);
             const p4 = project(xStart, boundaryY + 5, 5);

             ctx.beginPath();
             ctx.moveTo(p1.x, p1.y);
             ctx.lineTo(p2.x, p2.y);
             ctx.lineTo(p3.x, p3.y);
             ctx.lineTo(p4.x, p4.y);
             ctx.closePath();
             ctx.fill();
             ctx.stroke();
        };

        ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;

        if (mode === 'diffraction') {
            drawPlate(0, cx - slitWidth/2);
            drawPlate(cx + slitWidth/2, CANVAS_WIDTH);
        } else {
             // Left Wall: 0 to (cx - sep/2 - w/2)
             drawPlate(0, (cx - separation/2) - slitWidth/2);
             // Center Wall
             const centerStart = (cx - separation/2) + slitWidth/2;
             const centerEnd = (cx + separation/2) - slitWidth/2;
             if (centerEnd > centerStart) {
                drawPlate(centerStart, centerEnd);
             }
             // Right Wall
             const rightStart = (cx + separation/2) + slitWidth/2;
             drawPlate(rightStart, CANVAS_WIDTH);
        }
    }

    // Draw Lines in 3D (Analytical)
    const draw3DLines = (type, color) => {
        const lines = calculateInterferenceLines(wavelength, separation, type);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;

        lines.forEach(curve => {
            if (curve.length < 2) return;
            ctx.beginPath();
            let started = false;
            for (let i = 0; i < curve.length; i++) {
                 // For diffraction, clip before boundary
                 if (mode === 'diffraction-double' && curve[i].y <= boundaryY) continue;

                 let p = project(curve[i].x, curve[i].y, 0);
                 if (!started) {
                     ctx.moveTo(p.x, p.y);
                     started = true;
                 } else {
                     ctx.lineTo(p.x, p.y);
                 }
            }
            if (started) ctx.stroke();
        });
    };

    if (mode === 'double' || mode === 'diffraction-double') {
        if (showNodalLines) draw3DLines('nodal', 'rgba(255, 50, 50, 0.9)');
        if (showMaximaLines) draw3DLines('maxima', 'rgba(50, 255, 50, 0.9)');
    }

    // Draw sources (last, to be on top-ish)
    if (mode !== 'planar' && mode !== 'refraction' && mode !== 'diffraction' && mode !== 'diffraction-double') {
        ctx.fillStyle = '#ffcc00';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        for (const src of sources) {
            // Calculate z roughly at source location (approximation)
            const { x: px, y: py } = project(src.x, src.y, 10);
            ctx.beginPath();
            ctx.arc(px, py, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }
    }
  };

  const animate = (timestamp) => {
    if (isPlaying) {
      // Delta time in seconds
      const dt = 0.016;
      timeRef.current += dt * sourceSpeed;

      // Handle Doppler Emission
      if (mode === 'doppler') {
          const emissionPeriod = 1 / frequency;
          if (timeRef.current - lastEmitTimeRef.current >= emissionPeriod) {
            const sources = getSources(timeRef.current);
            // Add new wavefront at current source position
            wavefrontsRef.current.push({
                x: sources[0].x,
                y: sources[0].y,
                emitTime: timeRef.current
            });
            lastEmitTimeRef.current = timeRef.current;

            // Cleanup old wavefronts
            if (wavefrontsRef.current.length > 50) {
                wavefrontsRef.current.shift();
            }
          }
      }
    }

    const canvas = canvasRef.current;
    if (canvas) {
        const ctx = canvas.getContext('2d');
        if (ctx) {
            const sources = getSources(timeRef.current);
            if (viewMode === '2D') {
                draw2D(ctx, timeRef.current, sources);
            } else {
                draw3D(ctx, timeRef.current, sources);
            }
        }
    }

    requestRef.current = requestAnimationFrame(animate);
  };

  useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => {
        if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [isPlaying, viewMode, mode, showNodalLines, showMaximaLines, showRefractionAngles, frequency, separation, sourceSpeed, waveSpeedParam, slitWidth]);


  return (
    <div className="flex h-screen bg-gray-900 text-white font-sans overflow-hidden">
      {/* Sidebar Controls */}
      <div className="w-80 p-6 flex flex-col gap-6 bg-gray-800 border-r border-gray-700 shadow-xl overflow-y-auto z-10">
        <h1 className="text-2xl font-bold text-blue-400">Vågsimulator</h1>

        {/* Play/Pause */}
        <button
            onClick={() => setIsPlaying(!isPlaying)}
            className={`px-4 py-2 rounded-lg font-semibold transition-colors ${
                isPlaying ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'
            }`}
        >
            {isPlaying ? 'Pausa' : 'Starta'}
        </button>

        {/* View Mode */}
        <div className="flex flex-col gap-2">
            <label className="text-sm text-gray-400 uppercase tracking-wide">Vy</label>
            <div className="flex bg-gray-700 rounded-lg p-1">
                <button
                    onClick={() => setViewMode('2D')}
                    className={`flex-1 py-1 rounded-md text-sm transition-all ${viewMode === '2D' ? 'bg-blue-500 shadow' : 'text-gray-300 hover:text-white'}`}
                >
                    2D
                </button>
                <button
                    onClick={() => setViewMode('3D')}
                    className={`flex-1 py-1 rounded-md text-sm transition-all ${viewMode === '3D' ? 'bg-blue-500 shadow' : 'text-gray-300 hover:text-white'}`}
                >
                    3D
                </button>
            </div>
        </div>

        {/* Source Settings */}
        <div className="flex flex-col gap-2">
            <label className="text-sm text-gray-400 uppercase tracking-wide">Vågkällor</label>

            <select
                value={mode}
                onChange={(e) => setMode(e.target.value)}
                className="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
            >
                <option value="single">En punktkälla</option>
                <option value="double">Två punktkällor</option>
                <option value="planar">Plana vågor</option>
                <option value="refraction">Refraktion</option>
                <option value="diffraction">Diffraktion: en öppning</option>
                <option value="diffraction-double">Diffraktion: två öppningar</option>
                <option value="doppler">Dopplereffekt</option>
            </select>

            {(mode === 'double' || mode === 'diffraction-double') && (
                <div className="flex flex-col gap-2 mt-2">
                    <div className="flex items-center gap-3">
                        <input
                            type="checkbox"
                            id="nodal"
                            checked={showNodalLines}
                            onChange={(e) => setShowNodalLines(e.target.checked)}
                            className="w-4 h-4 rounded border-gray-600 text-blue-500 focus:ring-blue-500 bg-gray-700"
                        />
                        <label htmlFor="nodal" className="text-sm">Visa nodlinjer (röd)</label>
                    </div>
                    <div className="flex items-center gap-3">
                        <input
                            type="checkbox"
                            id="maxima"
                            checked={showMaximaLines}
                            onChange={(e) => setShowMaximaLines(e.target.checked)}
                            className="w-4 h-4 rounded border-gray-600 text-green-500 focus:ring-green-500 bg-gray-700"
                        />
                        <label htmlFor="maxima" className="text-sm">Visa maximilinjer (grön)</label>
                    </div>
                </div>
            )}

            {mode === 'refraction' && (
                <div className="flex items-center gap-3 mt-2">
                    <input
                        type="checkbox"
                        id="angles"
                        checked={showRefractionAngles}
                        onChange={(e) => setShowRefractionAngles(e.target.checked)}
                        className="w-4 h-4 rounded border-gray-600 text-yellow-500 focus:ring-yellow-500 bg-gray-700"
                    />
                    <label htmlFor="angles" className="text-sm">Visa vinklar</label>
                </div>
            )}
        </div>

        {/* Sliders */}
        <div className="flex flex-col gap-4">
            <div>
                <div className="flex justify-between text-sm mb-1">
                    <span className="text-gray-300">Frekvens</span>
                    <span className="text-gray-400">{frequency.toFixed(1).replace('.', ',')} Hz</span>
                </div>
                <input
                    type="range" min="0.5" max="5" step="0.1"
                    value={frequency}
                    onChange={(e) => setFrequency(parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                />
            </div>

            <div>
                <div className="flex justify-between text-sm mb-1">
                    <span className="text-gray-300">Våglängd (i djupt vatten)</span>
                    <span className="text-gray-400">{(waveSpeedParam / frequency).toFixed(0)} px</span>
                </div>
                <input
                    type="range" min="20" max="200" step="1"
                    value={waveSpeedParam / frequency}
                    onChange={(e) => {
                         const lambda = parseFloat(e.target.value);
                         if (lambda > 0) setFrequency(waveSpeedParam / lambda);
                    }}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                />
            </div>

            <div>
                <div className="flex justify-between text-sm mb-1">
                    <span className="text-gray-300">Simuleringshastighet</span>
                    <span className="text-gray-400">{sourceSpeed.toFixed(1).replace('.', ',')}x</span>
                </div>
                <input
                    type="range" min="0" max="3" step="0.1"
                    value={sourceSpeed}
                    onChange={(e) => setSourceSpeed(parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                />
            </div>

            {(mode === 'double' || mode === 'diffraction-double') && (
                <div>
                    <div className="flex justify-between text-sm mb-1">
                        <span className="text-gray-300">Avstånd</span>
                        <span className="text-gray-400">{separation} px</span>
                    </div>
                    <input
                        type="range" min="50" max="400" step="10"
                        value={separation}
                        onChange={(e) => setSeparation(parseFloat(e.target.value))}
                        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                </div>
            )}

            {(mode === 'diffraction' || mode === 'diffraction-double') && (
                <div>
                    <div className="flex justify-between text-sm mb-1">
                        <span className="text-gray-300">Öppningsbredd</span>
                        <span className="text-gray-400">{slitWidth} px</span>
                    </div>
                    <input
                        type="range" min="20" max="300" step="5"
                        value={slitWidth}
                        onChange={(e) => setSlitWidth(parseFloat(e.target.value))}
                        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500"
                    />
                </div>
            )}
        </div>
      </div>

      {/* Main Canvas Area */}
      <div className="flex-1 relative flex items-center justify-center bg-black cursor-crosshair">
         <canvas
            ref={canvasRef}
            width={800}
            height={600}
            className="rounded shadow-2xl bg-black"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseLeave}
            style={{ maxWidth: '100%', maxHeight: '100%' }}
         />
         {viewMode === '3D' && (
             <div className="absolute bottom-4 right-4 bg-black/60 text-white px-3 py-1 rounded text-xs pointer-events-none">
                 Dra för att rotera kameran
             </div>
         )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<WaveSimulator />);
    </script>
</body>
</html>
