<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arkimedes princip - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <div class="breadcrumb">
            <a href="index.html">Hem</a> / <a href="fysik1.html">Fysik 1</a> / <span>Arkimedes Princip</span>
        </div>

        <section class="intro-section">
            <h1 class="section-title">Arkimedes Princip</h1>
            <p class="intro-text">
                Utforska förhållandet mellan lyftkraft och undanträngt vatten med ett dynamometer-experiment.
            </p>
        </section>

        <div id="root"></div>
    </main>

    <footer class="footer">
        <p>&copy; 2025 Fysiklabbet. Skapad för gymnasieelever.</p>
    </footer>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // Constants
        const DENSITY_OF_WATER_G_PER_CM3 = 1.0;
        const GRAVITY_N_PER_G = 0.00980665;

        // Helper function to format numbers with comma
        const formatNumber = (num, decimals = 2) => {
            return num.toFixed(decimals).replace('.', ',');
        };

        // Initial state
        const INITIAL_DYNAMOMETER_STATE = {
            volume: 400,
            density: 2.55,
            submersion: 0,
        };

        // Scale Component
        const Scale = ({ value, label, x, y, width }) => (
            <g transform={`translate(${x}, ${y})`}>
                <rect x={0} y={0} width={width} height={50} rx={5} fill="#1E293B" stroke="#475569" />
                <text x={width / 2} y={20} textAnchor="middle" fill="#94A3B8" fontSize="12">{label}</text>
                <text x={width / 2} y={40} textAnchor="middle" fill="#67E8F9" fontSize="16" fontWeight="bold">
                    {formatNumber(value)} N
                </text>
            </g>
        );

        // Dynamometer Visual Component
        const DynamometerVisual = ({ calculations, state, setDynamometerState }) => {
            const { volume } = state;
            const { apparentWeight, submergedVolume, weightOfDisplacedWater, stoneCurrentY } = calculations;

            const [isAnimatingOverflow, setIsAnimatingOverflow] = useState(false);
            const animationTimeoutRef = useRef(null);
            const prevSubmergedVolumeRef = useRef(submergedVolume);

            const [isDragging, setIsDragging] = useState(false);
            const dragStartRef = useRef({ y: 0, submersion: 0 });

            useEffect(() => {
                const prevVolume = prevSubmergedVolumeRef.current;
                prevSubmergedVolumeRef.current = submergedVolume;

                if (submergedVolume > prevVolume) {
                    setIsAnimatingOverflow(true);

                    if (animationTimeoutRef.current) {
                        clearTimeout(animationTimeoutRef.current);
                    }

                    animationTimeoutRef.current = setTimeout(() => {
                        setIsAnimatingOverflow(false);
                    }, 500);
                } else if (submergedVolume <= 0) {
                    setIsAnimatingOverflow(false);
                    if (animationTimeoutRef.current) {
                        clearTimeout(animationTimeoutRef.current);
                    }
                }

                return () => {
                    if (animationTimeoutRef.current) {
                        clearTimeout(animationTimeoutRef.current);
                    }
                };
            }, [submergedVolume]);

            const handleDragStart = (e) => {
                e.preventDefault();
                setIsDragging(true);
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                dragStartRef.current = { y, submersion: state.submersion };
            };

            useEffect(() => {
                if (!isDragging) return;

                const handleDragMove = (e) => {
                    const y = e.touches ? e.touches[0].clientY : e.clientY;
                    const deltaY = y - dragStartRef.current.y;

                    const { travelStartY, travelEndY } = calculations;
                    const travelDistance = travelEndY - travelStartY;

                    if (travelDistance === 0) return;

                    const submersionDelta = deltaY / travelDistance;
                    let newSubmersion = dragStartRef.current.submersion + submersionDelta;

                    newSubmersion = Math.max(0, Math.min(1, newSubmersion));

                    setDynamometerState(prev => ({ ...prev, submersion: newSubmersion }));
                };

                const handleDragEnd = () => {
                    setIsDragging(false);
                };

                window.addEventListener('mousemove', handleDragMove);
                window.addEventListener('touchmove', handleDragMove);
                window.addEventListener('mouseup', handleDragEnd);
                window.addEventListener('touchend', handleDragEnd);

                return () => {
                    window.removeEventListener('mousemove', handleDragMove);
                    window.removeEventListener('touchmove', handleDragMove);
                    window.removeEventListener('mouseup', handleDragEnd);
                    window.removeEventListener('touchend', handleDragEnd);
                };
            }, [isDragging, calculations, setDynamometerState]);

            const stoneSize = Math.cbrt(volume) * 4.5;
            const stonePath = `M 0 -${stoneSize*0.6} L ${stoneSize*0.5} 0 L ${stoneSize*0.3} ${stoneSize*0.7} L -${stoneSize*0.3} ${stoneSize*0.7} L -${stoneSize*0.5} 0 Z`;

            const waterLevelY = 80;
            const stoneTopHookY = stoneCurrentY - stoneSize * 0.6;
            const dynamometerCenterY = stoneTopHookY - 100;

            const maxOverflowVolume = 1000;
            const overflowWaterHeight = (submergedVolume / maxOverflowVolume) * 100;

            const bodyWidth = 22;
            const bodyHeight = 150;
            const maxWeight = 50;

            const scaleTopMargin = 15;
            const scaleBottomMargin = 25;
            const scaleHeight = bodyHeight - scaleTopMargin - scaleBottomMargin;
            const scaleStartY = -bodyHeight / 2 + scaleTopMargin;

            const plungerExtension = Math.min(scaleHeight, Math.max(0, (apparentWeight / maxWeight) * scaleHeight));

            const markings = [];
            for (let i = 0; i <= 5; i++) {
                const newtons = i * 10;
                const yPos = scaleStartY + (newtons / maxWeight) * scaleHeight;
                markings.push(
                    <g key={`mark-${newtons}`}>
                        <line x1={-bodyWidth/2} y1={yPos} x2={-bodyWidth/2 - 5} y2={yPos} stroke="#94A3B8" strokeWidth="1" />
                        <text x={-bodyWidth/2 - 8} y={yPos + 3} textAnchor="end" fontSize="9" fill="#E2E8F0">{newtons}</text>
                    </g>
                );
            }

            return (
                <>
                    <g
                        onMouseDown={handleDragStart}
                        onTouchStart={handleDragStart}
                        style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
                    >
                        {/* Dynamometer */}
                        <g transform={`translate(175, ${dynamometerCenterY})`} style={{ transition: 'transform 0.2s ease-out' }}>
                            <path d={`M 0 ${-bodyHeight/2 - 25} C -12 ${-bodyHeight/2 - 35}, 12 ${-bodyHeight/2 - 35}, 0 ${-bodyHeight/2 - 25} L 0 ${-bodyHeight/2 - 12}`} stroke="#E2E8F0" strokeWidth="2.5" fill="none" />
                            <rect x={-bodyWidth/2 - 3} y={-bodyHeight/2 - 12} width={bodyWidth + 6} height={12} rx="3" fill="#94A3B8" />
                            <rect x={-bodyWidth/2} y={-bodyHeight/2} width={bodyWidth} height={bodyHeight} rx="6" fill="#0E7490" stroke="#475569" strokeWidth="1.5" />
                            <rect x={-2.5} y={-bodyHeight/2 + 10} width="5" height={bodyHeight - 20} fill="#1E293B" rx="2" />
                            {markings}

                            <g transform={`translate(0, ${plungerExtension})`}>
                                <path d={`M -8 ${scaleStartY} H 8`} stroke="#F87171" strokeWidth="2" />
                                <path
                                    d={`M 0 ${scaleStartY} V ${bodyHeight/2 + 5} C -10 ${bodyHeight/2 + 15}, 10 ${bodyHeight/2 + 15}, 0 ${bodyHeight/2 + 5}`}
                                    stroke="#E2E8F0" strokeWidth="2.5" fill="none"
                                />
                            </g>

                            <g transform={`translate(${bodyWidth / 2 + 10}, 0)`}>
                                <rect x={0} y={-25} width={70} height={50} rx={5} fill="#1E293B" stroke="#475569" />
                                <text x={35} y={-5} textAnchor="middle" fill="#94A3B8" fontSize="12">Avläsning</text>
                                <text x={35} y={15} textAnchor="middle" fill="#67E8F9" fontSize="16" fontWeight="bold">
                                    {formatNumber(apparentWeight)} N
                                </text>
                            </g>
                        </g>

                        <line
                            x1="175"
                            y1={dynamometerCenterY + (bodyHeight/2 + 5) + plungerExtension}
                            x2="175"
                            y2={stoneTopHookY}
                            stroke="#94A3B8"
                            strokeWidth="2"
                        />

                        <g transform={`translate(175, ${stoneCurrentY})`} style={{ transition: 'transform 0.2s ease-out' }}>
                            <path d={stonePath} fill="#64748B" stroke="#1E293B" strokeWidth="2"/>
                        </g>
                    </g>

                    {/* Overflow Beaker */}
                    <g transform="translate(50, 50)">
                        <path d="M0,0 V200 H200 V80 M200,60 V0" fill="none" stroke="#475569" strokeWidth="2"/>
                        <path d="M200,60 L230,70 M200,80 L230,90" fill="none" stroke="#475569" strokeWidth="2"/>
                        <rect x="1" y={waterLevelY} width="198" height={200 - waterLevelY} fill="#0891B2" fillOpacity="0.4" />
                        <line x1="0" y1={waterLevelY} x2="200" y2={waterLevelY} stroke="#67E8F9" strokeWidth="2" />
                        {isAnimatingOverflow &&
                            <path d="M230 90 Q 240 90, 250 140" stroke="#0E7490" strokeWidth="4" fill="none">
                                <animate attributeName="stroke-dasharray" from="0, 200" to="200, 0" dur="2s" repeatCount="indefinite" />
                            </path>
                        }
                    </g>

                    {/* Catch Beaker */}
                    <g transform="translate(280, 140)">
                        <path d="M0,0 V100 H120 V0" fill="none" stroke="#475569" strokeWidth="2" />
                        <rect
                            x="1"
                            y={100 - overflowWaterHeight}
                            width="118"
                            height={overflowWaterHeight}
                            fill="#0E7490"
                            style={{ transition: 'y 0.5s ease-in-out, height 0.5s ease-in-out' }}
                        />
                        <text x="60" y="-8" textAnchor="middle" fill="#94A3B8" fontSize="12">Undanträngt vatten</text>
                    </g>

                    <Scale value={weightOfDisplacedWater} label="Vattnets tyngd" x={280} y={250} width={120} />
                </>
            );
        };

        // Simulation Component
        const Simulation = ({ dynamometerCalculations, dynamometerState, setDynamometerState }) => {
            return (
                <div style={{ position: 'relative' }}>
                    <svg viewBox="0 -130 480 480" style={{ width: '100%', height: 'auto' }} aria-labelledby="sim-title" role="img">
                        <title id="sim-title">Simulation av Arkimedes Princip - Dynamometer</title>
                        <DynamometerVisual calculations={dynamometerCalculations} state={dynamometerState} setDynamometerState={setDynamometerState}/>
                    </svg>
                </div>
            );
        };

        // Slider Component
        const Slider = ({ label, value, min, max, step, unit, onChange }) => (
            <div style={{ marginBottom: '1.5rem' }}>
                <label htmlFor={label} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', color: '#CBD5E1', marginBottom: '0.5rem' }}>
                    <span>{label}</span>
                    <span style={{ fontFamily: 'monospace', color: '#67E8F9', fontSize: '1.125rem' }}>
                        {formatNumber(value, label === 'Sänkningsgrad' ? 0 : 2)} {unit}
                    </span>
                </label>
                <input
                    id={label}
                    type="range"
                    min={min}
                    max={max}
                    step={step}
                    value={value}
                    onChange={onChange}
                    style={{ width: '100%', cursor: 'pointer' }}
                />
            </div>
        );

        // Controls Component
        const Controls = ({ dynamometerState, setDynamometerState, initialDynamometerState }) => {
            const handleDynamometerVolumeChange = (e) => {
                setDynamometerState(prev => ({...prev, volume: Number(e.target.value)}));
            };

            const handleDynamometerDensityChange = (e) => {
                setDynamometerState(prev => ({...prev, density: Number(e.target.value)}));
            };

            const handleDynamometerSubmersionChange = (e) => {
                setDynamometerState(prev => ({...prev, submersion: Number(e.target.value) / 100}));
            };

            return (
                <div style={{ padding: '1.5rem', backgroundColor: '#1E293B', borderRadius: '12px', boxShadow: '0 4px 15px rgba(0,0,0,0.1)' }}>
                    <h2 style={{ fontSize: '1.5rem', fontWeight: '600', color: 'white', borderBottom: '2px solid #06B6D4', paddingBottom: '0.5rem', marginBottom: '1.5rem' }}>Kontrollpanel</h2>

                    <Slider
                        label="Sänkningsgrad"
                        value={dynamometerState.submersion * 100}
                        onChange={handleDynamometerSubmersionChange}
                        min={0}
                        max={100}
                        step={1}
                        unit="%"
                    />
                    <Slider
                        label="Stenens volym"
                        value={dynamometerState.volume}
                        onChange={handleDynamometerVolumeChange}
                        min={100}
                        max={1000}
                        step={25}
                        unit="cm³"
                    />

                    <Slider
                        label="Stenens densitet"
                        value={dynamometerState.density}
                        onChange={handleDynamometerDensityChange}
                        min={1.5}
                        max={5.0}
                        step={0.05}
                        unit="g/cm³"
                    />
                    <div style={{ paddingTop: '1rem' }}>
                        <button
                            onClick={() => setDynamometerState(initialDynamometerState)}
                            style={{
                                width: '100%',
                                backgroundColor: '#0891B2',
                                color: 'white',
                                fontWeight: 'bold',
                                padding: '0.75rem 1rem',
                                borderRadius: '8px',
                                border: 'none',
                                cursor: 'pointer',
                                transition: 'background-color 0.2s'
                            }}
                            onMouseOver={(e) => e.target.style.backgroundColor = '#0E7490'}
                            onMouseOut={(e) => e.target.style.backgroundColor = '#0891B2'}
                        >
                            Återställ
                        </button>
                    </div>
                </div>
            );
        };

        // Result Row Component
        const ResultRow = ({ label, value, isHighlighted }) => (
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: '0.5rem',
                borderRadius: '6px',
                backgroundColor: isHighlighted ? 'rgba(6, 182, 212, 0.2)' : 'transparent'
            }}>
                <span style={{ color: '#94A3B8' }}>{label}</span>
                <span style={{ fontFamily: 'monospace', fontSize: '1.125rem', color: isHighlighted ? '#67E8F9' : '#E2E8F0' }}>{value}</span>
            </div>
        );

        // Results Component
        const Results = ({ dynamometerCalculations }) => {
            return (
                <div style={{ padding: '1.5rem', backgroundColor: '#1E293B', borderRadius: '12px', boxShadow: '0 4px 15px rgba(0,0,0,0.1)' }}>
                    <h2 style={{ fontSize: '1.5rem', fontWeight: '600', color: 'white', borderBottom: '2px solid #06B6D4', paddingBottom: '0.5rem', marginBottom: '1.5rem' }}>Resultat</h2>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                        <ResultRow label="Stenens tyngd (luft)" value={`${formatNumber(dynamometerCalculations.weightInAir)} N`} />
                        <ResultRow label="Uppmätt tyngd (Dynamometer)" value={`${formatNumber(dynamometerCalculations.apparentWeight)} N`} />
                        <ResultRow label="Tyngdminskning (Lyftkraft)" value={`${formatNumber(dynamometerCalculations.buoyantForce)} N`} isHighlighted={true} />
                        <ResultRow label="Undanträngt vattens tyngd" value={`${formatNumber(dynamometerCalculations.weightOfDisplacedWater)} N`} isHighlighted={true} />
                    </div>
                    <p style={{ fontSize: '0.875rem', textAlign: 'center', paddingTop: '0.5rem', color: '#67E8F9' }}>
                        Notera: Tyngdminskningen (lyftkraften) är lika med det undanträngda vattnets tyngd!
                    </p>
                </div>
            );
        };

        // Explanation Component
        const Explanation = () => {
            return (
                <div style={{ padding: '1.5rem', backgroundColor: '#1E293B', borderRadius: '12px', boxShadow: '0 4px 15px rgba(0,0,0,0.1)', marginTop: '2rem' }}>
                    <h2 style={{ fontSize: '1.5rem', fontWeight: '600', color: 'white', borderBottom: '2px solid #06B6D4', paddingBottom: '0.5rem', marginBottom: '1rem' }}>Vad är Arkimedes Princip?</h2>
                    <p style={{ color: '#CBD5E1', marginBottom: '1rem' }}>
                        Arkimedes princip säger att <strong style={{ color: '#67E8F9' }}>den lyftkraft som verkar på ett föremål nedsänkt i en vätska är lika stor som tyngden av den vätska som föremålet tränger undan.</strong>
                    </p>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', color: '#94A3B8' }}>
                        <div>
                            <h3 style={{ fontWeight: '600', fontSize: '1.125rem', color: '#E2E8F0', marginBottom: '0.5rem' }}>Hur fungerar det?</h3>
                            <p>
                                När ett objekt sänks ner i en vätska, minskar dess uppmätta tyngd på grund av en uppåtriktad lyftkraft. Ju mer av objektet som är under ytan, desto mer vatten trängs undan och desto större blir lyftkraften.
                            </p>
                            <p style={{ marginTop: '0.5rem' }}>
                                I detta experiment kan du se hur avläsningen på dynamometern minskar i takt med att stenen sänks ner. Tyngdminskningen är exakt lika stor som tyngden av det vatten som samlas upp i den mindre bägaren.
                            </p>
                        </div>
                        <div>
                            <h3 style={{ fontWeight: '600', fontSize: '1.125rem', color: '#E2E8F0', marginBottom: '0.5rem' }}>Testa själv!</h3>
                            <p>Använd reglagen för att ändra stenens <strong style={{ color: '#CBD5E1' }}>volym</strong>, <strong style={{ color: '#CBD5E1' }}>densitet</strong> och <strong style={{ color: '#CBD5E1' }}>sänkningsgrad</strong>. Se hur <strong style={{ color: '#67E8F9' }}>Tyngdminskningen (Lyftkraften)</strong> i resultatpanelen alltid matchar tyngden av det <strong style={{ color: '#67E8F9' }}>Undanträngda Vattnet</strong>.</p>
                        </div>
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [dynamometerState, setDynamometerState] = useState(INITIAL_DYNAMOMETER_STATE);

            const dynamometerCalculations = useMemo(() => {
                const { volume, density, submersion } = dynamometerState;

                const stoneSize = Math.cbrt(volume) * 4.5;
                const stoneHeight = stoneSize * 1.3;
                const stoneCenterToBottom = stoneSize * 0.7;

                const waterLevelY = 130;
                const travelStartY = 100;
                const travelEndY = waterLevelY + stoneSize * 1.5;

                const stoneCurrentY = travelStartY + (travelEndY - travelStartY) * submersion;

                const stoneBottomTipY = stoneCurrentY + stoneCenterToBottom;
                const submergedHeight = Math.max(0, stoneBottomTipY - waterLevelY);
                const submergedRatio = Math.min(1, submergedHeight / stoneHeight);

                const stoneMass = volume * density;
                const weightInAir = stoneMass * GRAVITY_N_PER_G;
                const submergedVolume = volume * submergedRatio;
                const massOfDisplacedWater = submergedVolume * DENSITY_OF_WATER_G_PER_CM3;
                const weightOfDisplacedWater = massOfDisplacedWater * GRAVITY_N_PER_G;
                const buoyantForce = weightOfDisplacedWater;
                const apparentWeight = weightInAir - buoyantForce;

                return { weightInAir, submergedVolume, weightOfDisplacedWater, buoyantForce, apparentWeight, stoneCurrentY, submergedRatio, travelStartY, travelEndY };
            }, [dynamometerState]);

            return (
                <div style={{ minHeight: '100vh', backgroundColor: '#0F172A', color: '#E2E8F0', fontFamily: 'system-ui, -apple-system, sans-serif', padding: '1rem' }}>
                    <main style={{ maxWidth: '1280px', margin: '0 auto' }}>
                        <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: '2rem', marginTop: '3rem' }}>
                            <div style={{ backgroundColor: '#1E293B', padding: '1.5rem', borderRadius: '12px', boxShadow: '0 4px 15px rgba(0,0,0,0.1)' }}>
                                <Simulation
                                    dynamometerCalculations={dynamometerCalculations}
                                    dynamometerState={dynamometerState}
                                    setDynamometerState={setDynamometerState}
                                />
                            </div>

                            <aside style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                                <Controls
                                    dynamometerState={dynamometerState}
                                    setDynamometerState={setDynamometerState}
                                    initialDynamometerState={INITIAL_DYNAMOMETER_STATE}
                                />
                                <Results
                                    dynamometerCalculations={dynamometerCalculations}
                                />
                            </aside>
                        </div>

                        <Explanation />
                    </main>
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
