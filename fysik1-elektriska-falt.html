<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elektriska fält - Fysiklabbet</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }
        .glass-card-light {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }
        .tool-btn {
            transition: all 0.2s ease;
        }
        .tool-btn:hover {
            transform: scale(1.05);
        }
        .tool-btn.active {
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
            border-color: rgba(56, 189, 248, 0.8);
        }
        .cursor-rotate {
            cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8'/%3E%3Cpath d='M21 3v5h-5'/%3E%3C/svg%3E") 12 12, pointer;
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        const formatNumber = (num, decimals = 2) => {
            return num.toFixed(decimals).replace('.', ',');
        };

        // Coulombs konstant
        const K = 8.99e9;

        const ElectricFieldSimulation = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [canvasSize, setCanvasSize] = useState({ width: 800, height: 500 });
            const [objects, setObjects] = useState([]);
            const [showFieldLines, setShowFieldLines] = useState(true);
            const [fieldLineDensity, setFieldLineDensity] = useState(8);
            const [dragging, setDragging] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [dragMode, setDragMode] = useState('move'); // 'move' eller 'rotate'
            const [selectedObject, setSelectedObject] = useState(null); // index för valt objekt (papperskorg)
            const [trashFading, setTrashFading] = useState(false); // För fade-out animation
            const [cursorMode, setCursorMode] = useState('default'); // 'default', 'grab', 'rotate'
            const justDraggedRef = useRef(false); // Förhindra att klick efter drag lägger till objekt
            const dragStartPos = useRef(null); // För att detektera klick vs drag
            const trashTimerRef = useRef(null); // Timer för att dölja papperskorgen
            const [testCharges, setTestCharges] = useState([]);
            const [placingTestCharge, setPlacingTestCharge] = useState(null); // null | 1 | -1
            const [placingPos, setPlacingPos] = useState(null); // { x, y } musposition under placering
            const animFrameRef = useRef(null);
            const calculateFieldRef = useRef(null);
            const canvasSizeRef = useRef(canvasSize);
            const objectsRef = useRef(objects);

            // Beräkna elektriskt fält vid en punkt från alla objekt
            const calculateField = useCallback((x, y, excludeIndex = -1) => {
                let Ex = 0;
                let Ey = 0;

                objects.forEach((obj, index) => {
                    if (index === excludeIndex) return;

                    if (obj.type === 'charge') {
                        const dx = x - obj.x;
                        const dy = y - obj.y;
                        const r2 = dx * dx + dy * dy;
                        const r = Math.sqrt(r2);

                        if (r < 10) return; // Undvik singularitet nära laddningen

                        // E = k * Q / r^2, riktning utåt från positiv
                        const E = K * Math.abs(obj.charge * 1e-6) / r2;
                        const sign = obj.charge > 0 ? 1 : -1;

                        Ex += sign * E * (dx / r);
                        Ey += sign * E * (dy / r);
                    } else if (obj.type === 'plate') {
                        // Platta - approximera som linje av laddningar
                        const plateLength = obj.width;
                        const numCharges = 20;
                        const chargePerPoint = obj.charge / numCharges;

                        for (let i = 0; i < numCharges; i++) {
                            const t = (i + 0.5) / numCharges;
                            const px = obj.x + (t - 0.5) * plateLength * Math.cos(obj.angle || 0);
                            const py = obj.y + (t - 0.5) * plateLength * Math.sin(obj.angle || 0);

                            const dx = x - px;
                            const dy = y - py;
                            const r2 = dx * dx + dy * dy;
                            const r = Math.sqrt(r2);

                            if (r < 5) continue;

                            const E = K * Math.abs(chargePerPoint * 1e-6) / r2;
                            const sign = obj.charge > 0 ? 1 : -1;

                            Ex += sign * E * (dx / r);
                            Ey += sign * E * (dy / r);
                        }
                    }
                });

                return { Ex, Ey };
            }, [objects]);

            // Följ en fältlinje från en startpunkt
            const traceFieldLine = useCallback((startX, startY, direction) => {
                const points = [{ x: startX, y: startY }];
                let x = startX;
                let y = startY;
                const stepSize = 5;
                const maxSteps = 500;

                for (let i = 0; i < maxSteps; i++) {
                    const { Ex, Ey } = calculateField(x, y);
                    const magnitude = Math.sqrt(Ex * Ex + Ey * Ey);

                    if (magnitude < 1e-10) break;

                    // Normalisera och ta ett steg
                    const dx = direction * (Ex / magnitude) * stepSize;
                    const dy = direction * (Ey / magnitude) * stepSize;

                    x += dx;
                    y += dy;

                    // Kolla om vi är utanför canvas
                    if (x < 0 || x > canvasSize.width || y < 0 || y > canvasSize.height) break;

                    // Kolla om vi träffar en negativ laddning (om vi går i positiv riktning)
                    // eller positiv laddning (om vi går i negativ riktning)
                    let hitCharge = false;
                    for (const obj of objects) {
                        if (obj.type === 'charge') {
                            const dist = Math.sqrt((x - obj.x) ** 2 + (y - obj.y) ** 2);
                            if (dist < 25) {
                                hitCharge = true;
                                break;
                            }
                        } else if (obj.type === 'plate') {
                            // Kolla avstånd till plattan
                            const plateHalfLength = obj.width / 2;
                            const cos = Math.cos(obj.angle || 0);
                            const sin = Math.sin(obj.angle || 0);

                            // Projicera punkten på plattans linje
                            const dx = x - obj.x;
                            const dy = y - obj.y;
                            const proj = dx * cos + dy * sin;

                            if (Math.abs(proj) < plateHalfLength) {
                                const perpDist = Math.abs(-dx * sin + dy * cos);
                                if (perpDist < 7) {
                                    hitCharge = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (hitCharge) {
                        points.push({ x, y });
                        break;
                    }

                    points.push({ x, y });
                }

                return points;
            }, [calculateField, canvasSize, objects]);

            // Generera startpunkter för fältlinjer
            const generateFieldLines = useCallback(() => {
                const lines = [];

                objects.forEach(obj => {
                    if (obj.type === 'charge' && obj.charge > 0) {
                        // Starta fältlinjer från positiva laddningar
                        const numLines = fieldLineDensity;
                        for (let i = 0; i < numLines; i++) {
                            const angle = (2 * Math.PI * i) / numLines;
                            const startX = obj.x + 25 * Math.cos(angle);
                            const startY = obj.y + 25 * Math.sin(angle);
                            const points = traceFieldLine(startX, startY, 1);
                            if (points.length > 1) {
                                lines.push({ points, fromPositive: true });
                            }
                        }
                    } else if (obj.type === 'plate' && obj.charge > 0) {
                        // Starta fältlinjer från positiva plattor
                        const numLines = Math.ceil(fieldLineDensity * 1.5);
                        const plateLength = obj.width;
                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);

                        for (let i = 0; i < numLines; i++) {
                            const t = (i + 0.5) / numLines - 0.5;
                            const px = obj.x + t * plateLength * cos;
                            const py = obj.y + t * plateLength * sin;

                            // Starta linjer på båda sidor av plattan (7px = strax utanför ytan)
                            for (const side of [1, -1]) {
                                const startX = px + side * 7 * (-sin);
                                const startY = py + side * 7 * cos;
                                const points = traceFieldLine(startX, startY, 1);
                                if (points.length > 1) {
                                    lines.push({ points, fromPositive: true });
                                }
                            }
                        }
                    }
                });

                // Starta fältlinjer från negativa objekt (baklänges - från kanten in mot objektet)
                // Detta visar fältlinjer som kommer "utifrån" och går in i negativa laddningar
                objects.forEach(obj => {
                    if (obj.type === 'charge' && obj.charge < 0) {
                        // Starta fältlinjer baklänges från negativa laddningar
                        const numLines = fieldLineDensity;
                        for (let i = 0; i < numLines; i++) {
                            const angle = (2 * Math.PI * i) / numLines;
                            const startX = obj.x + 25 * Math.cos(angle);
                            const startY = obj.y + 25 * Math.sin(angle);
                            // Trace baklänges (direction = -1) för att hitta var linjen kommer ifrån
                            const points = traceFieldLine(startX, startY, -1);
                            if (points.length > 1) {
                                // Vänd punkterna så de går i rätt riktning (mot den negativa laddningen)
                                points.reverse();
                                // Kolla om linjen börjar utanför alla positiva objekt
                                const startPoint = points[0];
                                let startsFromPositive = false;
                                for (const other of objects) {
                                    if (other.charge > 0) {
                                        if (other.type === 'charge') {
                                            const dist = Math.sqrt((startPoint.x - other.x) ** 2 + (startPoint.y - other.y) ** 2);
                                            if (dist < 40) startsFromPositive = true;
                                        } else if (other.type === 'plate') {
                                            const plateHalfLength = other.width / 2;
                                            const cos = Math.cos(other.angle || 0);
                                            const sin = Math.sin(other.angle || 0);
                                            const dx = startPoint.x - other.x;
                                            const dy = startPoint.y - other.y;
                                            const proj = dx * cos + dy * sin;
                                            const perpDist = Math.abs(-dx * sin + dy * cos);
                                            if (Math.abs(proj) < plateHalfLength && perpDist < 30) startsFromPositive = true;
                                        }
                                    }
                                }
                                // Lägg bara till om linjen inte redan täcks av en positiv källa
                                if (!startsFromPositive) {
                                    lines.push({ points, fromPositive: false });
                                }
                            }
                        }
                    } else if (obj.type === 'plate' && obj.charge < 0) {
                        // Starta fältlinjer baklänges från negativa plattor
                        const numLines = Math.ceil(fieldLineDensity * 1.5);
                        const plateLength = obj.width;
                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);

                        for (let i = 0; i < numLines; i++) {
                            const t = (i + 0.5) / numLines - 0.5;
                            const px = obj.x + t * plateLength * cos;
                            const py = obj.y + t * plateLength * sin;

                            // Starta linjer på båda sidor av plattan (7px = strax utanför ytan)
                            for (const side of [1, -1]) {
                                const startX = px + side * 7 * (-sin);
                                const startY = py + side * 7 * cos;
                                // Trace baklänges för att hitta var linjen kommer ifrån
                                const points = traceFieldLine(startX, startY, -1);
                                if (points.length > 1) {
                                    // Vänd punkterna så de går i rätt riktning
                                    points.reverse();
                                    // Kolla om linjen börjar nära en positiv källa
                                    const startPoint = points[0];
                                    let startsFromPositive = false;
                                    for (const other of objects) {
                                        if (other.charge > 0) {
                                            if (other.type === 'charge') {
                                                const dist = Math.sqrt((startPoint.x - other.x) ** 2 + (startPoint.y - other.y) ** 2);
                                                if (dist < 40) startsFromPositive = true;
                                            } else if (other.type === 'plate') {
                                                const plateHalfLength = other.width / 2;
                                                const otherCos = Math.cos(other.angle || 0);
                                                const otherSin = Math.sin(other.angle || 0);
                                                const dx = startPoint.x - other.x;
                                                const dy = startPoint.y - other.y;
                                                const proj = dx * otherCos + dy * otherSin;
                                                const perpDist = Math.abs(-dx * otherSin + dy * otherCos);
                                                if (Math.abs(proj) < plateHalfLength && perpDist < 30) startsFromPositive = true;
                                            }
                                        }
                                    }
                                    // Lägg bara till om linjen kommer utifrån (inte från en positiv källa)
                                    if (!startsFromPositive) {
                                        lines.push({ points, fromPositive: false });
                                    }
                                }
                            }
                        }
                    }
                });

                return lines;
            }, [objects, fieldLineDensity, traceFieldLine, canvasSize]);

            // Refs för animationsloop
            useEffect(() => { calculateFieldRef.current = calculateField; }, [calculateField]);
            useEffect(() => { canvasSizeRef.current = canvasSize; }, [canvasSize]);
            useEffect(() => { objectsRef.current = objects; }, [objects]);

            // Memoisera fältlinjer (undvik omräkning vid testladdningsanimation)
            const fieldLines = useMemo(() => {
                if (!showFieldLines || objects.length === 0) return [];
                return generateFieldLines();
            }, [showFieldLines, objects, fieldLineDensity, generateFieldLines]);

            // Funktion för att lägga till objekt i mitten av canvas
            const addObject = useCallback((type) => {
                const centerX = canvasSize.width / 2;
                const centerY = canvasSize.height / 2;

                // Hitta en ledig plats nära mitten
                let x = centerX;
                let y = centerY;
                let offset = 0;

                // Om det redan finns objekt i mitten, flytta lite
                while (offset < 200) {
                    let collision = false;
                    for (const obj of objects) {
                        const dist = Math.sqrt((x - obj.x) ** 2 + (y - obj.y) ** 2);
                        if (dist < 60) {
                            collision = true;
                            break;
                        }
                    }
                    if (!collision) break;
                    offset += 50;
                    x = centerX + offset;
                }

                if (type === 'positiveCharge') {
                    setObjects(prev => [...prev, { type: 'charge', x, y, charge: 5 }]);
                } else if (type === 'negativeCharge') {
                    setObjects(prev => [...prev, { type: 'charge', x, y, charge: -5 }]);
                } else if (type === 'positivePlate') {
                    setObjects(prev => [...prev, { type: 'plate', x, y, charge: 10, width: 120, angle: Math.PI / 2 }]);
                } else if (type === 'negativePlate') {
                    setObjects(prev => [...prev, { type: 'plate', x, y, charge: -10, width: 120, angle: Math.PI / 2 }]);
                }
            }, [canvasSize, objects]);

            // Aktivera placeringsläge för testladdning
            const startPlacingTestCharge = useCallback((positive) => {
                setPlacingTestCharge(positive ? 1 : -1);
                setPlacingPos(null);
            }, []);

            // Hantera drag
            const handleMouseDown = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Om vi placerar en testladdning, släpp den här
                if (placingTestCharge !== null) {
                    setTestCharges(prev => [...prev, {
                        x, y,
                        charge: placingTestCharge,
                        trail: [],
                        stopped: false
                    }]);
                    setPlacingTestCharge(null);
                    setPlacingPos(null);
                    return;
                }

                // Spara startposition för att detektera klick vs drag
                dragStartPos.current = { x, y };

                for (let i = 0; i < objects.length; i++) {
                    const obj = objects[i];
                    if (obj.type === 'charge') {
                        const dist = Math.sqrt((x - obj.x) ** 2 + (y - obj.y) ** 2);
                        if (dist < 30) {
                            setDragging(i);
                            setSelectedObject(i); // Visa papperskorgen
                            setDragMode('move');
                            setDragOffset({ x: obj.x - x, y: obj.y - y });
                            return;
                        }
                    } else if (obj.type === 'plate') {
                        const plateHalfLength = obj.width / 2;
                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);
                        const dx = x - obj.x;
                        const dy = y - obj.y;
                        const proj = dx * cos + dy * sin; // Projektion längs plattan
                        const perpDist = Math.abs(-dx * sin + dy * cos); // Avstånd vinkelrätt mot plattan

                        // Utökad träffzon för rotation (lite utanför plattans ändar)
                        const hitPlate = Math.abs(proj) < plateHalfLength + 20 && perpDist < 30;

                        if (hitPlate) {
                            setDragging(i);
                            setSelectedObject(i); // Visa papperskorgen
                            // Om nära kanterna (>60% av halva längden) → rotera, annars flytta
                            if (Math.abs(proj) > plateHalfLength * 0.5) {
                                setDragMode('rotate');
                            } else {
                                setDragMode('move');
                                setDragOffset({ x: obj.x - x, y: obj.y - y });
                            }
                            return;
                        }
                    }
                }

                // Klickade inte på något objekt - avmarkera
                setSelectedObject(null);
            }, [objects, placingTestCharge]);

            const handleMouseMove = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Om vi placerar testladdning, uppdatera ghostposition
                if (placingTestCharge !== null) {
                    setPlacingPos({ x: mouseX, y: mouseY });
                    setCursorMode('default');
                    return;
                }

                // Om vi drar, hantera drag
                if (dragging !== null) {
                    if (dragMode === 'rotate') {
                        // Rotera plattan så att den pekar mot muspekaren
                        setObjects(prev => {
                            const newObjects = [...prev];
                            const obj = newObjects[dragging];
                            const dx = mouseX - obj.x;
                            const dy = mouseY - obj.y;
                            let newAngle = Math.atan2(dy, dx);

                            // Snap till 90-gradersvinklar (0, π/2, π, -π/2)
                            const snapAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2, -Math.PI];
                            const snapThreshold = 0.1; // ~5.7 grader
                            for (const snapAngle of snapAngles) {
                                if (Math.abs(newAngle - snapAngle) < snapThreshold) {
                                    newAngle = snapAngle;
                                    break;
                                }
                            }

                            newObjects[dragging] = { ...obj, angle: newAngle };
                            return newObjects;
                        });
                    } else {
                        // Flytta objektet
                        const x = Math.max(30, Math.min(canvasSize.width - 30, mouseX + dragOffset.x));
                        const y = Math.max(30, Math.min(canvasSize.height - 30, mouseY + dragOffset.y));

                        setObjects(prev => {
                            const newObjects = [...prev];
                            newObjects[dragging] = { ...newObjects[dragging], x, y };
                            return newObjects;
                        });
                    }
                    return;
                }

                // Detektera hover över objekt för cursor-ändring
                let newCursor = 'default';
                for (const obj of objects) {
                    if (obj.type === 'charge') {
                        const dist = Math.sqrt((mouseX - obj.x) ** 2 + (mouseY - obj.y) ** 2);
                        if (dist < 30) {
                            newCursor = 'grab';
                            break;
                        }
                    } else if (obj.type === 'plate') {
                        const plateHalfLength = obj.width / 2;
                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);
                        const dx = mouseX - obj.x;
                        const dy = mouseY - obj.y;
                        const proj = dx * cos + dy * sin;
                        const perpDist = Math.abs(-dx * sin + dy * cos);

                        const hitPlate = Math.abs(proj) < plateHalfLength + 20 && perpDist < 30;

                        if (hitPlate) {
                            // Om nära kanterna → rotation cursor
                            if (Math.abs(proj) > plateHalfLength * 0.5) {
                                newCursor = 'rotate';
                            } else {
                                newCursor = 'grab';
                            }
                            break;
                        }
                    }
                }
                setCursorMode(newCursor);
            }, [dragging, dragOffset, canvasSize, dragMode, objects, placingTestCharge]);

            const handleMouseUp = useCallback(() => {
                if (dragging !== null) {
                    justDraggedRef.current = true;
                    setTimeout(() => { justDraggedRef.current = false; }, 100);
                    // Återställ timern när man släpper objektet
                    resetTrashTimer();
                }
                setDragging(null);
                setDragMode('move');
                dragStartPos.current = null;
            }, [dragging, resetTrashTimer]);

            // Touch-hantering
            const handleTouchStart = useCallback((e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Om vi placerar en testladdning, släpp den här
                if (placingTestCharge !== null) {
                    setTestCharges(prev => [...prev, {
                        x, y,
                        charge: placingTestCharge,
                        trail: [],
                        stopped: false
                    }]);
                    setPlacingTestCharge(null);
                    setPlacingPos(null);
                    return;
                }

                // Spara startposition för att detektera tap vs drag
                dragStartPos.current = { x, y };

                for (let i = 0; i < objects.length; i++) {
                    const obj = objects[i];
                    if (obj.type === 'charge') {
                        const dist = Math.sqrt((x - obj.x) ** 2 + (y - obj.y) ** 2);
                        if (dist < 40) {
                            setDragging(i);
                            setSelectedObject(i); // Visa papperskorgen
                            setDragMode('move');
                            setDragOffset({ x: obj.x - x, y: obj.y - y });
                            return;
                        }
                    } else if (obj.type === 'plate') {
                        const plateHalfLength = obj.width / 2;
                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);
                        const dx = x - obj.x;
                        const dy = y - obj.y;
                        const proj = dx * cos + dy * sin;
                        const perpDist = Math.abs(-dx * sin + dy * cos);

                        // Utökad träffzon för rotation
                        const hitPlate = Math.abs(proj) < plateHalfLength + 25 && perpDist < 35;

                        if (hitPlate) {
                            setDragging(i);
                            setSelectedObject(i); // Visa papperskorgen
                            // Om nära kanterna → rotera, annars flytta
                            if (Math.abs(proj) > plateHalfLength * 0.5) {
                                setDragMode('rotate');
                            } else {
                                setDragMode('move');
                                setDragOffset({ x: obj.x - x, y: obj.y - y });
                            }
                            return;
                        }
                    }
                }

                // Tappade inte på något objekt - avmarkera
                setSelectedObject(null);
            }, [objects, placingTestCharge]);

            const handleTouchMove = useCallback((e) => {
                e.preventDefault();

                // Om vi placerar testladdning, uppdatera ghostposition
                if (placingTestCharge !== null) {
                    const touch = e.touches[0];
                    const rect = canvasRef.current.getBoundingClientRect();
                    setPlacingPos({ x: touch.clientX - rect.left, y: touch.clientY - rect.top });
                    return;
                }

                if (dragging === null) return;

                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                if (dragMode === 'rotate') {
                    // Rotera plattan så att den pekar mot fingret
                    setObjects(prev => {
                        const newObjects = [...prev];
                        const obj = newObjects[dragging];
                        const dx = touchX - obj.x;
                        const dy = touchY - obj.y;
                        const newAngle = Math.atan2(dy, dx);
                        newObjects[dragging] = { ...obj, angle: newAngle };
                        return newObjects;
                    });
                } else {
                    // Flytta objektet
                    const x = Math.max(30, Math.min(canvasSize.width - 30, touchX + dragOffset.x));
                    const y = Math.max(30, Math.min(canvasSize.height - 30, touchY + dragOffset.y));

                    setObjects(prev => {
                        const newObjects = [...prev];
                        newObjects[dragging] = { ...newObjects[dragging], x, y };
                        return newObjects;
                    });
                }
            }, [dragging, dragOffset, canvasSize, dragMode]);

            // Ta bort valt objekt
            const deleteSelectedObject = useCallback(() => {
                if (selectedObject !== null) {
                    setObjects(prev => prev.filter((_, idx) => idx !== selectedObject));
                    setSelectedObject(null);
                    setTrashFading(false);
                }
            }, [selectedObject]);

            // Starta timer för att dölja papperskorgen efter 2 sekunder
            const resetTrashTimer = useCallback(() => {
                // Rensa eventuell befintlig timer
                if (trashTimerRef.current) {
                    clearTimeout(trashTimerRef.current);
                }
                setTrashFading(false);

                // Starta ny timer
                trashTimerRef.current = setTimeout(() => {
                    setTrashFading(true);
                    // Efter fade-out (300ms), dölj helt
                    setTimeout(() => {
                        setSelectedObject(null);
                        setTrashFading(false);
                    }, 300);
                }, 2000);
            }, []);

            // Hantera timer när selectedObject ändras
            useEffect(() => {
                if (selectedObject !== null) {
                    resetTrashTimer();
                }
                return () => {
                    if (trashTimerRef.current) {
                        clearTimeout(trashTimerRef.current);
                    }
                };
            }, [selectedObject, resetTrashTimer]);

            // Animationsloop för testladdningar
            useEffect(() => {
                if (testCharges.length === 0) {
                    if (animFrameRef.current) {
                        cancelAnimationFrame(animFrameRef.current);
                        animFrameRef.current = null;
                    }
                    return;
                }

                let lastTime = performance.now();

                const animate = (time) => {
                    const dt = Math.min((time - lastTime) / 1000, 0.04);
                    lastTime = time;

                    setTestCharges(prev => {
                        if (prev.every(tc => tc.stopped)) return prev;

                        const calcField = calculateFieldRef.current;
                        const cs = canvasSizeRef.current;
                        const objs = objectsRef.current;
                        if (!calcField) return prev;

                        return prev.map(tc => {
                            if (tc.stopped) return tc;

                            const { Ex, Ey } = calcField(tc.x, tc.y);
                            const mag = Math.sqrt(Ex * Ex + Ey * Ey);
                            if (mag < 1e-10) return { ...tc, stopped: true };

                            const speed = 100;
                            const dir = tc.charge > 0 ? 1 : -1;
                            const newX = tc.x + dir * (Ex / mag) * speed * dt;
                            const newY = tc.y + dir * (Ey / mag) * speed * dt;

                            // Kantcheck
                            if (newX < 5 || newX > cs.width - 5 || newY < 5 || newY > cs.height - 5) {
                                return { ...tc, stopped: true };
                            }

                            // Kolla om den träffar en källaddning/platta
                            for (const obj of objs) {
                                if (obj.type === 'charge') {
                                    const dist = Math.sqrt((newX - obj.x) ** 2 + (newY - obj.y) ** 2);
                                    if (dist < 22) return { ...tc, stopped: true };
                                } else if (obj.type === 'plate') {
                                    const cos = Math.cos(obj.angle || 0);
                                    const sin = Math.sin(obj.angle || 0);
                                    const pdx = newX - obj.x;
                                    const pdy = newY - obj.y;
                                    const proj = pdx * cos + pdy * sin;
                                    const perp = Math.abs(-pdx * sin + pdy * cos);
                                    if (Math.abs(proj) < obj.width / 2 && perp < 8) return { ...tc, stopped: true };
                                }
                            }

                            const trail = [...tc.trail, { x: tc.x, y: tc.y }];
                            if (trail.length > 200) trail.shift();
                            return { ...tc, x: newX, y: newY, trail };
                        });
                    });

                    animFrameRef.current = requestAnimationFrame(animate);
                };

                animFrameRef.current = requestAnimationFrame(animate);
                return () => {
                    if (animFrameRef.current) {
                        cancelAnimationFrame(animFrameRef.current);
                        animFrameRef.current = null;
                    }
                };
            }, [testCharges.length === 0]);

            // Rita canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvasSize;

                canvas.width = width;
                canvas.height = height;

                // Rensa canvas
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, width, height);

                // Bakgrundseffekt
                const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.6);
                bgGradient.addColorStop(0, 'rgba(10, 30, 60, 0.3)');
                bgGradient.addColorStop(1, 'rgba(5, 5, 16, 0)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, width, height);

                // Subtilt rutnät
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.08)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Rita fältlinjer (memoiserade)
                if (fieldLines.length > 0) {
                    fieldLines.forEach(line => {
                        if (line.points.length < 2) return;

                        ctx.beginPath();
                        ctx.moveTo(line.points[0].x, line.points[0].y);

                        for (let i = 1; i < line.points.length; i++) {
                            ctx.lineTo(line.points[i].x, line.points[i].y);
                        }

                        ctx.strokeStyle = 'rgba(251, 191, 36, 0.6)';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();

                        // Rita pilar längs linjen för att visa riktning
                        const arrowInterval = 40;
                        let distance = 0;

                        for (let i = 1; i < line.points.length; i++) {
                            const dx = line.points[i].x - line.points[i-1].x;
                            const dy = line.points[i].y - line.points[i-1].y;
                            distance += Math.sqrt(dx * dx + dy * dy);

                            if (distance > arrowInterval) {
                                distance = 0;
                                const angle = Math.atan2(dy, dx);
                                const x = line.points[i].x;
                                const y = line.points[i].y;
                                const arrowSize = 6;

                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x - arrowSize * Math.cos(angle - Math.PI/6), y - arrowSize * Math.sin(angle - Math.PI/6));
                                ctx.moveTo(x, y);
                                ctx.lineTo(x - arrowSize * Math.cos(angle + Math.PI/6), y - arrowSize * Math.sin(angle + Math.PI/6));
                                ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)';
                                ctx.lineWidth = 1.5;
                                ctx.stroke();
                            }
                        }
                    });
                }

                // Rita objekt
                objects.forEach((obj, index) => {
                    if (obj.type === 'charge') {
                        const isPositive = obj.charge > 0;
                        const color = isPositive ? '#ef4444' : '#38bdf8';
                        const glowColor = isPositive ? 'rgba(239, 68, 68, 0.5)' : 'rgba(56, 189, 248, 0.5)';
                        const radius = 22;

                        // Glöd
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = glowColor;

                        // Gradient för laddningen
                        const gradient = ctx.createRadialGradient(obj.x - 5, obj.y - 5, 3, obj.x, obj.y, radius);
                        gradient.addColorStop(0, isPositive ? '#fca5a5' : '#7dd3fc');
                        gradient.addColorStop(0.5, color);
                        gradient.addColorStop(1, isPositive ? '#991b1b' : '#0369a1');

                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();

                        ctx.strokeStyle = isPositive ? '#fecaca' : '#bae6fd';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.shadowBlur = 0;

                        // Plus eller minus tecken
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Poppins, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(isPositive ? '+' : '−', obj.x, obj.y);

                    } else if (obj.type === 'plate') {
                        const isPositive = obj.charge > 0;
                        const color = isPositive ? '#ef4444' : '#38bdf8';
                        const glowColor = isPositive ? 'rgba(239, 68, 68, 0.4)' : 'rgba(56, 189, 248, 0.4)';

                        const cos = Math.cos(obj.angle || 0);
                        const sin = Math.sin(obj.angle || 0);
                        const halfLength = obj.width / 2;

                        // Startpunkt och slutpunkt
                        const x1 = obj.x - halfLength * cos;
                        const y1 = obj.y - halfLength * sin;
                        const x2 = obj.x + halfLength * cos;
                        const y2 = obj.y + halfLength * sin;

                        // Glöd
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = glowColor;

                        // Rita plattan som en tjock linje med raka ändar
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 10;
                        ctx.lineCap = 'butt';
                        ctx.stroke();

                        ctx.shadowBlur = 0;

                        // Rita plus/minus-tecken längs plattan
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 14px Poppins, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        const numSigns = 5;
                        for (let i = 0; i < numSigns; i++) {
                            const t = (i + 0.5) / numSigns - 0.5;
                            const sx = obj.x + t * obj.width * cos;
                            const sy = obj.y + t * obj.width * sin;
                            ctx.fillText(isPositive ? '+' : '−', sx, sy);
                        }
                    }
                });

                // Rita testladdningar med spår
                testCharges.forEach(tc => {
                    const isPositive = tc.charge > 0;
                    const trailColor = isPositive ? [252, 165, 165] : [125, 211, 252];

                    // Rita spår med fadande opacitet (i batchar för prestanda)
                    if (tc.trail.length > 1) {
                        const numBatches = 12;
                        ctx.lineWidth = 2.5;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        for (let b = 0; b < numBatches; b++) {
                            const start = Math.floor(b * tc.trail.length / numBatches);
                            const end = Math.floor((b + 1) * tc.trail.length / numBatches);
                            if (start >= end) continue;

                            const alpha = ((b + 1) / numBatches) * 0.6;
                            ctx.beginPath();
                            ctx.moveTo(tc.trail[start].x, tc.trail[start].y);
                            for (let i = start + 1; i <= Math.min(end, tc.trail.length - 1); i++) {
                                ctx.lineTo(tc.trail[i].x, tc.trail[i].y);
                            }
                            ctx.strokeStyle = `rgba(${trailColor[0]}, ${trailColor[1]}, ${trailColor[2]}, ${alpha})`;
                            ctx.stroke();
                        }

                        // Linje från sista spårpunkten till nuvarande position
                        ctx.beginPath();
                        ctx.moveTo(tc.trail[tc.trail.length - 1].x, tc.trail[tc.trail.length - 1].y);
                        ctx.lineTo(tc.x, tc.y);
                        ctx.strokeStyle = `rgba(${trailColor[0]}, ${trailColor[1]}, ${trailColor[2]}, 0.7)`;
                        ctx.lineWidth = 2.5;
                        ctx.stroke();
                    }

                    // Rita testladdningen (liten cirkel)
                    const radius = 8;
                    const color = isPositive ? '#ef4444' : '#38bdf8';
                    const glowColor = isPositive ? 'rgba(239, 68, 68, 0.6)' : 'rgba(56, 189, 248, 0.6)';

                    ctx.shadowBlur = 12;
                    ctx.shadowColor = glowColor;

                    ctx.beginPath();
                    ctx.arc(tc.x, tc.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = isPositive ? '#fecaca' : '#bae6fd';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    ctx.shadowBlur = 0;

                    // Plus/minus-tecken
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Poppins, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isPositive ? '+' : '−', tc.x, tc.y);
                });

                // Rita ghost-testladdning (följer muspekaren under placering)
                if (placingTestCharge !== null && placingPos) {
                    const isPositive = placingTestCharge > 0;
                    const color = isPositive ? 'rgba(239, 68, 68, 0.5)' : 'rgba(56, 189, 248, 0.5)';
                    const glowColor = isPositive ? 'rgba(239, 68, 68, 0.3)' : 'rgba(56, 189, 248, 0.3)';
                    const radius = 8;

                    ctx.shadowBlur = 15;
                    ctx.shadowColor = glowColor;

                    ctx.beginPath();
                    ctx.arc(placingPos.x, placingPos.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.setLineDash([3, 3]);
                    ctx.strokeStyle = isPositive ? 'rgba(254, 202, 202, 0.7)' : 'rgba(186, 230, 253, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.shadowBlur = 0;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = 'bold 12px Poppins, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isPositive ? '+' : '−', placingPos.x, placingPos.y);
                }

            }, [objects, canvasSize, showFieldLines, fieldLines, testCharges, placingTestCharge, placingPos]);

            // Hantera resize
            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        setCanvasSize({ width: rect.width, height: Math.max(400, rect.height) });
                    }
                };

                window.addEventListener('resize', handleResize);
                setTimeout(handleResize, 50);
                setTimeout(handleResize, 200);

                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const clearAll = () => {
                setObjects([]);
                setTestCharges([]);
                setPlacingTestCharge(null);
                setPlacingPos(null);
                setSelectedObject(null);
            };

            const loadPreset = (preset) => {
                setSelectedObject(null);
                setTestCharges([]);
                setPlacingTestCharge(null);
                setPlacingPos(null);
                if (preset === 'dipole') {
                    setObjects([
                        { type: 'charge', x: canvasSize.width / 2 - 80, y: canvasSize.height / 2, charge: 5 },
                        { type: 'charge', x: canvasSize.width / 2 + 80, y: canvasSize.height / 2, charge: -5 }
                    ]);
                } else if (preset === 'twoPositive') {
                    setObjects([
                        { type: 'charge', x: canvasSize.width / 2 - 80, y: canvasSize.height / 2, charge: 5 },
                        { type: 'charge', x: canvasSize.width / 2 + 80, y: canvasSize.height / 2, charge: 5 }
                    ]);
                } else if (preset === 'capacitor') {
                    setObjects([
                        { type: 'plate', x: canvasSize.width / 2 - 60, y: canvasSize.height / 2, charge: 10, width: 150, angle: Math.PI / 2 },
                        { type: 'plate', x: canvasSize.width / 2 + 60, y: canvasSize.height / 2, charge: -10, width: 150, angle: Math.PI / 2 }
                    ]);
                } else if (preset === 'parallelPlates') {
                    setObjects([
                        { type: 'plate', x: canvasSize.width / 2, y: canvasSize.height / 2 - 60, charge: 10, width: 200, angle: 0 },
                        { type: 'plate', x: canvasSize.width / 2, y: canvasSize.height / 2 + 60, charge: -10, width: 200, angle: 0 }
                    ]);
                } else if (preset === 'quadrupole') {
                    const cx = canvasSize.width / 2;
                    const cy = canvasSize.height / 2;
                    const d = 70;
                    setObjects([
                        { type: 'charge', x: cx - d, y: cy - d, charge: 5 },
                        { type: 'charge', x: cx + d, y: cy - d, charge: -5 },
                        { type: 'charge', x: cx - d, y: cy + d, charge: -5 },
                        { type: 'charge', x: cx + d, y: cy + d, charge: 5 }
                    ]);
                }
            };

            return (
                <div className="dark-container min-h-screen">
                    <div className="max-w-6xl mx-auto py-8 px-4">
                        {/* Header */}
                        <header className="text-center mb-8">
                            <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-cyan-400 tracking-tight glow-text mb-4">
                                Elektriska fält
                            </h1>
                            <p className="text-slate-400 max-w-2xl mx-auto leading-relaxed">
                                Utforska hur elektriska fält uppstår kring laddningar och laddade plattor.
                                Klicka för att placera ut objekt och se hur fältlinjerna ritas ut.
                            </p>
                        </header>

                        {/* Main layout */}
                        <div className="flex flex-col lg:flex-row gap-6 mb-6">
                            {/* Canvas */}
                            <div className="glass-card rounded-2xl p-4 flex-grow lg:flex-grow-[2]">
                                <div
                                    ref={containerRef}
                                    className={`relative w-full ${placingTestCharge !== null ? 'cursor-crosshair' : cursorMode === 'rotate' ? 'cursor-rotate' : cursorMode === 'grab' ? 'cursor-grab' : 'cursor-default'}`}
                                    style={{ minHeight: '450px' }}
                                >
                                    <canvas
                                        ref={canvasRef}
                                        className="block touch-none rounded-lg"
                                        style={{ width: '100%', height: '100%' }}
                                        onMouseDown={handleMouseDown}
                                        onMouseMove={handleMouseMove}
                                        onMouseUp={handleMouseUp}
                                        onMouseLeave={() => { handleMouseUp(); setCursorMode('default'); setPlacingPos(null); }}
                                        onTouchStart={handleTouchStart}
                                        onTouchMove={handleTouchMove}
                                        onTouchEnd={handleMouseUp}
                                    />
                                    {/* Papperskorg för att ta bort objekt */}
                                    {selectedObject !== null && objects[selectedObject] && (
                                        <button
                                            onClick={deleteSelectedObject}
                                            className={`absolute flex items-center justify-center w-7 h-7 bg-red-500/90 hover:bg-red-600 rounded-full shadow-lg transform hover:scale-110 transition-all duration-300 ${trashFading ? 'opacity-0 scale-75' : 'opacity-100 scale-100'}`}
                                            style={{
                                                left: objects[selectedObject].x + (objects[selectedObject].type === 'charge' ? 18 : 25),
                                                top: objects[selectedObject].y - (objects[selectedObject].type === 'charge' ? 32 : 40),
                                                zIndex: 10
                                            }}
                                            title="Ta bort"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                            </svg>
                                        </button>
                                    )}
                                </div>
                            </div>

                            {/* Controls */}
                            <div className="flex flex-col gap-4 lg:w-72">
                                {/* Lägg till objekt */}
                                <div className="glass-card-light p-4 rounded-xl">
                                    <h3 className="text-slate-200 font-semibold mb-3 text-sm">Lägg till</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button
                                            onClick={() => addObject('positiveCharge')}
                                            className="tool-btn p-3 rounded-lg flex flex-col items-center gap-1 bg-red-500/20 border-2 border-red-400/50 hover:bg-red-500/30 hover:border-red-400"
                                        >
                                            <span className="text-2xl">⊕</span>
                                            <span className="text-xs text-slate-300">+ laddning</span>
                                        </button>
                                        <button
                                            onClick={() => addObject('negativeCharge')}
                                            className="tool-btn p-3 rounded-lg flex flex-col items-center gap-1 bg-cyan-500/20 border-2 border-cyan-400/50 hover:bg-cyan-500/30 hover:border-cyan-400"
                                        >
                                            <span className="text-2xl">⊖</span>
                                            <span className="text-xs text-slate-300">− laddning</span>
                                        </button>
                                        <button
                                            onClick={() => addObject('positivePlate')}
                                            className="tool-btn p-3 rounded-lg flex flex-col items-center gap-1 bg-red-500/20 border-2 border-red-400/50 hover:bg-red-500/30 hover:border-red-400"
                                        >
                                            <span className="text-lg text-red-400">▮ +</span>
                                            <span className="text-xs text-slate-300">+ platta</span>
                                        </button>
                                        <button
                                            onClick={() => addObject('negativePlate')}
                                            className="tool-btn p-3 rounded-lg flex flex-col items-center gap-1 bg-cyan-500/20 border-2 border-cyan-400/50 hover:bg-cyan-500/30 hover:border-cyan-400"
                                        >
                                            <span className="text-lg text-cyan-400">▮ −</span>
                                            <span className="text-xs text-slate-300">− platta</span>
                                        </button>
                                    </div>
                                    <div className="mt-3 pt-3 border-t border-slate-600/30">
                                        <h4 className="text-slate-400 text-xs mb-2">Testladdningar</h4>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button
                                                onClick={() => startPlacingTestCharge(true)}
                                                className={`tool-btn p-2 rounded-lg flex flex-col items-center gap-1 border border-dashed ${placingTestCharge === 1 ? 'bg-red-500/30 border-red-400 shadow-[0_0_10px_rgba(239,68,68,0.3)]' : 'bg-red-500/10 border-red-400/40 hover:bg-red-500/20 hover:border-red-400/70'}`}
                                            >
                                                <span className="text-sm text-red-300">+</span>
                                                <span className="text-xs text-slate-400">{placingTestCharge === 1 ? 'Placera...' : '+ test'}</span>
                                            </button>
                                            <button
                                                onClick={() => startPlacingTestCharge(false)}
                                                className={`tool-btn p-2 rounded-lg flex flex-col items-center gap-1 border border-dashed ${placingTestCharge === -1 ? 'bg-cyan-500/30 border-cyan-400 shadow-[0_0_10px_rgba(56,189,248,0.3)]' : 'bg-cyan-500/10 border-cyan-400/40 hover:bg-cyan-500/20 hover:border-cyan-400/70'}`}
                                            >
                                                <span className="text-sm text-cyan-300">−</span>
                                                <span className="text-xs text-slate-400">{placingTestCharge === -1 ? 'Placera...' : '− test'}</span>
                                            </button>
                                        </div>
                                        {placingTestCharge !== null && (
                                            <p className="text-xs text-amber-400/80 mt-2 text-center">Klicka på ritytan för att placera</p>
                                        )}
                                        {testCharges.length > 0 && (
                                            <button
                                                onClick={() => setTestCharges([])}
                                                className="w-full mt-2 px-2 py-1.5 text-xs text-slate-400 hover:text-slate-300 bg-slate-700/30 hover:bg-slate-700/50 rounded-lg"
                                            >
                                                Rensa testladdningar
                                            </button>
                                        )}
                                    </div>
                                </div>

                                {/* Förinställningar */}
                                <div className="glass-card-light p-4 rounded-xl">
                                    <h3 className="text-slate-200 font-semibold mb-3 text-sm">Förinställningar</h3>
                                    <div className="flex flex-col gap-2">
                                        <button
                                            onClick={() => loadPreset('dipole')}
                                            className="px-3 py-2 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-sm text-slate-300 text-left"
                                        >
                                            Dipol (+/−)
                                        </button>
                                        <button
                                            onClick={() => loadPreset('twoPositive')}
                                            className="px-3 py-2 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-sm text-slate-300 text-left"
                                        >
                                            Två positiva (+/+)
                                        </button>
                                        <button
                                            onClick={() => loadPreset('capacitor')}
                                            className="px-3 py-2 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-sm text-slate-300 text-left"
                                        >
                                            Kondensator
                                        </button>
                                        <button
                                            onClick={() => loadPreset('parallelPlates')}
                                            className="px-3 py-2 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-sm text-slate-300 text-left"
                                        >
                                            Två parallella plattor
                                        </button>
                                        <button
                                            onClick={() => loadPreset('quadrupole')}
                                            className="px-3 py-2 bg-slate-700/50 hover:bg-slate-700 rounded-lg text-sm text-slate-300 text-left"
                                        >
                                            Kvadrupol
                                        </button>
                                    </div>
                                </div>

                                {/* Inställningar */}
                                <div className="glass-card-light p-4 rounded-xl">
                                    <h3 className="text-slate-200 font-semibold mb-3 text-sm">Inställningar</h3>
                                    <label className="flex items-center gap-2 cursor-pointer mb-3">
                                        <input
                                            type="checkbox"
                                            checked={showFieldLines}
                                            onChange={(e) => setShowFieldLines(e.target.checked)}
                                            className="w-4 h-4 rounded border-slate-600 bg-slate-700 text-cyan-500"
                                        />
                                        <span className="text-slate-300 text-sm">Visa fältlinjer</span>
                                    </label>
                                    <div className="mb-3">
                                        <label className="text-slate-400 text-xs mb-1 block">Linjetäthet: {fieldLineDensity}</label>
                                        <input
                                            type="range"
                                            min="4"
                                            max="16"
                                            value={fieldLineDensity}
                                            onChange={(e) => setFieldLineDensity(parseInt(e.target.value))}
                                            className="w-full"
                                        />
                                    </div>
                                    <button
                                        onClick={clearAll}
                                        className="w-full px-3 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-500/50 rounded-lg text-sm text-red-400"
                                    >
                                        Rensa allt
                                    </button>
                                </div>

                                {/* Info */}
                                <div className="glass-card rounded-xl p-4">
                                    <h3 className="text-slate-200 font-semibold text-sm mb-2">Instruktioner</h3>
                                    <ul className="text-slate-400 text-xs space-y-1">
                                        <li>• Klicka på knapparna ovan för att lägga till</li>
                                        <li>• Dra i <strong>mitten</strong> för att flytta</li>
                                        <li>• Dra i <strong>ändarna</strong> för att rotera plattor</li>
                                        <li>• Klicka på objekt → 🗑️ för att ta bort</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        {/* Info cards */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-amber-500/20 rounded-lg">
                                        <span className="text-amber-400 text-xl">→</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Fältlinjer</h3>
                                        <p className="text-slate-400 text-sm">
                                            Fältlinjer går alltid <strong>ut från positiva</strong> laddningar och <strong>in i negativa</strong>.
                                            De visar riktningen på kraften som en positiv provladdning skulle känna.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-cyan-500/20 rounded-lg">
                                        <span className="text-cyan-400 text-xl font-bold">≡</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Fältstyrka</h3>
                                        <p className="text-slate-400 text-sm">
                                            Ju <strong>tätare fältlinjerna</strong> ligger, desto starkare är det elektriska fältet.
                                            Fältet är starkast nära laddningarna.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-red-500/20 rounded-lg">
                                        <span className="text-red-400 text-xl font-bold">▮▮</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Homogent fält</h3>
                                        <p className="text-slate-400 text-sm">
                                            Mellan två parallella plattor (kondensator) blir fältet nästan <strong>homogent</strong> -
                                            linjerna är parallella och jämnt fördelade.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<ElectricFieldSimulation />);
    </script>
</body>
</html>
