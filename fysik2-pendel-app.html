<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan pendel - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Import map to resolve "three" -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>

    <style>
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #canvas-container canvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link active">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <main class="min-h-screen w-full bg-gray-100 text-gray-800 flex flex-col lg:flex-row">
        <div id="canvas-container" class="flex-grow min-h-[600px] w-full lg:w-1/2 relative bg-white">
            <div class="absolute top-4 left-4 text-gray-900 p-2 rounded-lg z-10">
                <h1 class="text-2xl md:text-4xl font-bold tracking-tighter">Plan pendel (matematisk)</h1>
            </div>
        </div>
        <div class="w-full lg:w-1/2 bg-white/60 backdrop-blur-md p-6 md:p-8 flex flex-col space-y-8 overflow-y-auto" id="controls-container">
        </div>
    </main>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const celestialBodies = [
            { name: 'Solen', gravity: 274.0, gradient: 'linear-gradient(45deg, #fef08a, #f97316)' },
            { name: 'Merkurius', gravity: 3.7, gradient: 'linear-gradient(45deg, #e5e5e5, #a3a3a3)' },
            { name: 'Venus', gravity: 8.87, gradient: 'linear-gradient(45deg, #fef3c7, #f59e0b)' },
            { name: 'Jorden', gravity: 9.81, gradient: 'linear-gradient(45deg, #22c55e, #3b82f6)' },
            { name: 'Månen', gravity: 1.62, gradient: 'linear-gradient(45deg, #f5f5f5, #a3a3a3)' },
            { name: 'Mars', gravity: 3.72, gradient: 'linear-gradient(45deg, #fb923c, #ef4444)' },
            { name: 'Jupiter', gravity: 24.79, gradient: 'linear-gradient(45deg, #fcd34d, #d97706, #f5f5f5)' },
            { name: 'Saturnus', gravity: 10.44, gradient: 'linear-gradient(45deg, #fde68a, #ca8a04)' },
            { name: 'Uranus', gravity: 8.69, gradient: 'linear-gradient(45deg, #7dd3fc, #0ea5e9)' },
            { name: 'Neptunus', gravity: 11.15, gradient: 'linear-gradient(45deg, #3b82f6, #1e3a8a)' },
        ];

        // State
        let params = {
            length: 1.5,
            gravity: 9.81,
            mass: 0.15,
            initialAngle: 0,
            damping: 0.05,
        };

        let simulationState = 'idle';
        let timer = 0;
        let swingCount = 0;
        let measuredPeriod = null;
        let timeRef = 0;
        let swingCountRef = 0;

        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(0, 1.8, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(8, 6, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xC4A484 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Lab stand
        const standMaterial = new THREE.MeshStandardMaterial({ color: 0xBDBDBD, metalness: 0.8, roughness: 0.2 });

        const VERTICAL_OFFSET = 1.0;
        const PIVOT_Z_OFFSET = 0.4;
        const verticalRodPositionX = -0.4;

        function createLabStand(pendulumLength) {
            const standGroup = new THREE.Group();
            const PIVOT_Y = pendulumLength + VERTICAL_OFFSET;
            const verticalRodHeight = PIVOT_Y + 0.5;

            // Base
            const baseGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            const base = new THREE.Mesh(baseGeometry, standMaterial);
            base.position.set(verticalRodPositionX, -0.5 + 0.05, 0);
            base.castShadow = true;
            base.receiveShadow = true;
            standGroup.add(base);

            // Vertical rod
            const verticalRodGeometry = new THREE.CylinderGeometry(0.04, 0.04, verticalRodHeight, 16);
            const verticalRod = new THREE.Mesh(verticalRodGeometry, standMaterial);
            verticalRod.position.set(verticalRodPositionX, -0.5 + verticalRodHeight / 2, 0);
            verticalRod.castShadow = true;
            standGroup.add(verticalRod);

            // Clamp 1
            const clamp1Geometry = new THREE.BoxGeometry(0.12, 0.15, 0.12);
            const clamp1 = new THREE.Mesh(clamp1Geometry, standMaterial);
            clamp1.position.set(verticalRodPositionX, PIVOT_Y, 0);
            clamp1.castShadow = true;
            standGroup.add(clamp1);

            // Horizontal rod 1
            const horizontalRod1Geometry = new THREE.CylinderGeometry(0.04, 0.04, Math.abs(verticalRodPositionX), 16);
            const horizontalRod1 = new THREE.Mesh(horizontalRod1Geometry, standMaterial);
            horizontalRod1.position.set(verticalRodPositionX / 2, PIVOT_Y, 0);
            horizontalRod1.rotation.z = Math.PI / 2;
            horizontalRod1.castShadow = true;
            standGroup.add(horizontalRod1);

            // Clamp 2
            const clamp2Geometry = new THREE.BoxGeometry(0.12, 0.12, 0.15);
            const clamp2 = new THREE.Mesh(clamp2Geometry, standMaterial);
            clamp2.position.set(0, PIVOT_Y, 0);
            clamp2.castShadow = true;
            standGroup.add(clamp2);

            // Horizontal rod 2
            const horizontalRod2Geometry = new THREE.CylinderGeometry(0.04, 0.04, PIVOT_Z_OFFSET, 16);
            const horizontalRod2 = new THREE.Mesh(horizontalRod2Geometry, standMaterial);
            horizontalRod2.position.set(0, PIVOT_Y, PIVOT_Z_OFFSET / 2);
            horizontalRod2.rotation.x = Math.PI / 2;
            horizontalRod2.castShadow = true;
            standGroup.add(horizontalRod2);

            return standGroup;
        }

        let labStand = createLabStand(params.length);
        scene.add(labStand);

        // Pendulum
        const pendulumGroup = new THREE.Group();

        function createPendulum(length, mass) {
            // Clear existing pendulum
            while(pendulumGroup.children.length > 0) {
                pendulumGroup.remove(pendulumGroup.children[0]);
            }

            const PIVOT_Y = length + VERTICAL_OFFSET;
            pendulumGroup.position.set(0, PIVOT_Y, PIVOT_Z_OFFSET);

            // Pivot
            const pivotGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const pivotMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const pivot = new THREE.Mesh(pivotGeometry, pivotMaterial);
            pendulumGroup.add(pivot);

            // String
            const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, length, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -length / 2;
            pendulumGroup.add(string);

            // Bob
            const bobRadius = 0.18 * Math.cbrt(mass);
            const bobHeight = bobRadius * 3.5;
            const bobGeometry = new THREE.CylinderGeometry(bobRadius, bobRadius, bobHeight, 32);
            const bobMaterial = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, metalness: 0.2, roughness: 0.5 });
            const bob = new THREE.Mesh(bobGeometry, bobMaterial);
            bob.position.y = -length - bobHeight / 2;
            bob.castShadow = true;
            pendulumGroup.add(bob);

            return bob;
        }

        const bob = createPendulum(params.length, params.mass);
        scene.add(pendulumGroup);

        // Visual aids for angle
        const angleVisualsGroup = new THREE.Group();
        scene.add(angleVisualsGroup);

        function updateAngleVisuals() {
            // Clear previous visuals
            while(angleVisualsGroup.children.length > 0) {
                angleVisualsGroup.remove(angleVisualsGroup.children[0]);
            }

            if (Math.abs(params.initialAngle) > 0.1 && simulationState === 'idle') {
                const PIVOT_Y = params.length + VERTICAL_OFFSET;

                // Dashed vertical line (plumb line)
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: 0x666666,
                    dashSize: 0.1,
                    gapSize: 0.05,
                });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, PIVOT_Y, PIVOT_Z_OFFSET),
                    new THREE.Vector3(0, PIVOT_Y - params.length - 0.3, PIVOT_Z_OFFSET)
                ]);
                const plumbLine = new THREE.Line(lineGeometry, lineMaterial);
                plumbLine.computeLineDistances();
                angleVisualsGroup.add(plumbLine);

                // Angle arc - from vertical line to pendulum string
                const angleRad = (params.initialAngle * Math.PI) / 180;
                const arcRadius = params.length * 0.25;
                const arcPoints = [];
                const steps = 20;

                // Arc goes from vertical (0) to the pendulum angle
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const angle = angleRad * t; // 0 to angleRad
                    arcPoints.push(new THREE.Vector3(
                        Math.sin(angle) * arcRadius,
                        PIVOT_Y - Math.cos(angle) * arcRadius,
                        PIVOT_Z_OFFSET
                    ));
                }

                const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
                const arcMaterial = new THREE.LineBasicMaterial({ color: 0x3b82f6, linewidth: 2 });
                const arc = new THREE.Line(arcGeometry, arcMaterial);
                angleVisualsGroup.add(arc);

                // Angle text using canvas texture
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = '#000000';  // Black text
                context.font = 'Bold 28px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                const angleText = params.initialAngle.toFixed(1).replace('.', ',') + '°';
                context.fillText(angleText, 64, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);

                // Position text closer to arc and higher up
                const textAngle = angleRad / 2;
                const textRadius = arcRadius * 1.15;  // Closer to arc
                sprite.position.set(
                    Math.sin(textAngle) * textRadius,
                    PIVOT_Y - Math.cos(textAngle) * textRadius,  // Higher up
                    PIVOT_Z_OFFSET
                );
                sprite.scale.set(0.35, 0.175, 1);
                angleVisualsGroup.add(sprite);
            }
        }

        // Update camera target
        function updateCameraTarget() {
            const PIVOT_Y = params.length + VERTICAL_OFFSET;
            controls.target.set(0, PIVOT_Y - params.length / 2, 0);
            controls.update();
        }
        updateCameraTarget();

        // Mouse interaction for dragging pendulum
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (isDragging && simulationState === 'idle') {
                raycaster.setFromCamera(mouse, camera);

                // Calculate angle based on mouse position
                const pivotY = params.length + VERTICAL_OFFSET;
                const pivotPos = new THREE.Vector3(0, pivotY, PIVOT_Z_OFFSET);

                // Project mouse ray onto a plane at the pendulum's Z position
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -PIVOT_Z_OFFSET);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);

                if (intersection) {
                    // Calculate angle from pivot to intersection point
                    const dx = intersection.x - pivotPos.x;
                    const dy = intersection.y - pivotPos.y;
                    const angle = Math.atan2(dx, -dy); // Negative dy because y is up

                    // Limit angle to ±25 degrees
                    const angleDeg = (angle * 180) / Math.PI;
                    params.initialAngle = Math.max(-25, Math.min(25, angleDeg));

                    // Update slider position
                    const angleSlider = document.getElementById('angle-slider');
                    if (angleSlider) angleSlider.value = params.initialAngle;

                    updateAngleVisuals();
                    updateValueDisplays();
                }
            }
        }

        function onMouseDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (simulationState === 'idle') {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(bob, true);

                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false; // Disable orbit controls while dragging
                }
            }
        }

        function onMouseUp() {
            if (isDragging && params.initialAngle >= 0.5 && simulationState === 'idle') {
                // Auto-start simulation when releasing after drag
                simulationState = 'running';
                timer = 0;
                timeRef = 0;
                swingCount = 0;
                swingCountRef = 0;
                measuredPeriod = null;
                updateAngleVisuals(); // Clear angle visuals when starting
                renderUI();
            }
            isDragging = false;
            controls.enabled = true;
        }

        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            if (simulationState === 'running') {
                const delta = 1/60;
                timeRef += delta;
                timer = timeRef;

                const initialAngleRad = (params.initialAngle * Math.PI) / 180;
                const omega = Math.sqrt(params.gravity / params.length);
                const angle = initialAngleRad * Math.exp(-params.damping * timeRef) * Math.cos(omega * timeRef);

                pendulumGroup.rotation.z = angle;

                const currentSwings = Math.floor((omega * timeRef) / (2 * Math.PI));
                if (currentSwings !== swingCountRef) {
                    swingCountRef = currentSwings;
                    swingCount = currentSwings;
                    renderUI();
                }

                if (swingCountRef >= 10) {
                    simulationState = 'finished';
                    measuredPeriod = timer / 10;
                    renderUI();
                }

                renderUI();
            } else {
                const initialAngleRad = (params.initialAngle * Math.PI) / 180;
                pendulumGroup.rotation.z = initialAngleRad;
                updateAngleVisuals();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Controls UI - separated into render and event setup
        function renderUI() {
            const period = 2 * Math.PI * Math.sqrt(params.length / params.gravity);
            const isIdle = simulationState === 'idle';

            const controlsHTML = `
                <div class="space-y-6">
                    <h2 class="text-xl font-bold text-gray-800 border-b-2 border-blue-500 pb-2">Kontrollpanel</h2>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Trådlängd (l)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'bg-blue-100 text-blue-700' : 'bg-gray-200 text-gray-500'}">
                                ${params.length.toFixed(2).replace('.', ',')} m
                            </span>
                        </div>
                        <input id="length-slider" type="range" min="0.5" max="5" step="0.1" value="${params.length}" ${!isIdle ? 'disabled' : ''}
                            class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg accent-blue-500 disabled:accent-gray-400 disabled:bg-gray-200 disabled:cursor-not-allowed">
                    </div>

                    <div>
                        <div class="w-full">
                            <div class="flex justify-between items-center mb-1">
                                <label class="text-sm font-medium ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Tyngdfaktor (g)</label>
                                <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'bg-blue-100 text-blue-700' : 'bg-gray-200 text-gray-500'}">
                                    ${params.gravity.toFixed(2).replace('.', ',')} m/s²
                                </span>
                            </div>
                            <input id="gravity-slider" type="range" min="1" max="25" step="0.1" value="${params.gravity}" ${!isIdle ? 'disabled' : ''}
                                class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg accent-blue-500 disabled:accent-gray-400 disabled:bg-gray-200 disabled:cursor-not-allowed">
                        </div>
                        <div class="mt-4">
                            <label class="text-sm font-medium mb-2 block ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Eller välj en himlakropp:</label>
                            <div class="flex flex-wrap justify-center gap-3">
                                ${celestialBodies.map(body => {
                                    const isSelected = Math.abs(params.gravity - body.gravity) < 0.01;
                                    return `
                                        <div class="flex flex-col items-center">
                                            <button data-gravity="${body.gravity}" class="celestial-button p-1 rounded-full transition-all duration-200 focus:outline-none ${!isIdle ? 'opacity-50 cursor-not-allowed' : ''} ${isSelected ? 'bg-blue-200 ring-2 ring-blue-500 ring-offset-2 ring-offset-white' : 'bg-gray-200 hover:bg-gray-300'}"
                                                ${!isIdle ? 'disabled' : ''} title="${body.name} (g = ${body.gravity.toFixed(2).replace('.', ',')} m/s²)">
                                                <div class="w-10 h-10 rounded-full" style="background-image: ${body.gradient}"></div>
                                            </button>
                                            <span class="text-xs mt-1 ${isIdle ? 'text-gray-600' : 'text-gray-400'}">${body.name}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Massa (m)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'bg-blue-100 text-blue-700' : 'bg-gray-200 text-gray-500'}">
                                ${(params.mass * 1000).toFixed(0)} g
                            </span>
                        </div>
                        <input id="mass-slider" type="range" min="10" max="300" step="5" value="${params.mass * 1000}" ${!isIdle ? 'disabled' : ''}
                            class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg accent-blue-500 disabled:accent-gray-400 disabled:bg-gray-200 disabled:cursor-not-allowed">
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Startvinkel (θ)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'bg-blue-100 text-blue-700' : 'bg-gray-200 text-gray-500'}">
                                ${params.initialAngle.toFixed(2).replace('.', ',')} °
                            </span>
                        </div>
                        <input id="angle-slider" type="range" min="0" max="25" step="0.5" value="${params.initialAngle}" ${!isIdle ? 'disabled' : ''}
                            class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg accent-blue-500 disabled:accent-gray-400 disabled:bg-gray-200 disabled:cursor-not-allowed">
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-gray-700' : 'text-gray-400'}">Dämpning</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'bg-blue-100 text-blue-700' : 'bg-gray-200 text-gray-500'}">
                                ${params.damping.toFixed(2).replace('.', ',')}
                            </span>
                        </div>
                        <input id="damping-slider" type="range" min="0" max="0.5" step="0.01" value="${params.damping}" ${!isIdle ? 'disabled' : ''}
                            class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg accent-blue-500 disabled:accent-gray-400 disabled:bg-gray-200 disabled:cursor-not-allowed">
                    </div>

                    <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg text-center space-y-2">
                        <h3 class="text-lg font-semibold text-blue-800">Mätning</h3>
                        ${simulationState === 'idle' ? '<p class="text-sm text-blue-700">Justera vinkeln och klicka Starta.</p>' : ''}
                        ${simulationState === 'running' ? `
                            <div class="flex justify-around items-center">
                                <div>
                                    <p class="text-sm text-gray-600">Svängningar</p>
                                    <p class="text-3xl font-mono font-bold text-gray-800">${swingCount} / 10</p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600">Tid</p>
                                    <p class="text-3xl font-mono font-bold text-gray-800">${timer.toFixed(2).replace('.', ',')} s</p>
                                </div>
                            </div>
                        ` : ''}
                        ${simulationState === 'finished' && measuredPeriod !== null ? `
                            <div class="space-y-3">
                                <div>
                                    <p class="text-sm text-gray-600">Total tid (10 svängningar)</p>
                                    <p class="text-3xl font-mono font-bold text-gray-800">${timer.toFixed(2).replace('.', ',')} s</p>
                                </div>
                                <div class="border-t border-blue-200 pt-3">
                                    <p class="text-sm text-gray-600">Uppmätt Period (T)</p>
                                    <p class="text-3xl font-mono font-bold text-green-600">${measuredPeriod.toFixed(3).replace('.', ',')} s</p>
                                </div>
                            </div>
                        ` : ''}
                    </div>

                    <div class="flex items-center justify-center space-x-4 pt-4">
                        <button id="start-button" ${!isIdle || params.initialAngle < 0.5 ? 'disabled' : ''}
                            class="px-6 py-2 font-semibold text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-100 w-32 disabled:bg-blue-300 disabled:cursor-not-allowed">
                            Starta
                        </button>
                        <button id="reset-button"
                            class="px-6 py-2 font-semibold text-white bg-gray-600 rounded-lg hover:bg-gray-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-100 w-32">
                            Återställ
                        </button>
                    </div>
                </div>

                <div class="space-y-4 p-6 bg-white/50 rounded-lg border border-gray-200">
                    <h2 class="text-xl font-bold text-gray-800 border-b-2 border-blue-500 pb-2">Information</h2>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">Beräknad Period (T)</p>
                        <p class="text-4xl font-mono font-bold text-blue-600 my-2">${period.toFixed(3).replace('.', ',')} s</p>
                        <p class="text-sm font-mono text-gray-500">T = 2π * √(l/g)</p>
                    </div>
                    <div class="pt-4 text-sm text-gray-700 leading-relaxed">
                        <p>
                            <strong class="text-blue-600">Observera:</strong> Perioden – tiden för en komplett svängning fram och tillbaka – beror <strong class="font-semibold">endast</strong> på pendelns <span class="text-green-600">längd (l)</span> och den lokala <span class="text-green-600">tyngdfaktorn (g)</span>.
                        </p>
                        <p class="mt-2">
                            Prova att ändra <span class="text-red-600">massan (m)</span> och <span class="text-red-600">startvinkeln (θ)</span>. Du kommer se att perioden förblir oförändrad. Detta är en fundamental egenskap hos en enkel pendel (för små vinklar).
                        </p>
                        <p class="mt-2">
                            <strong class="text-blue-600">Dämpning</strong> simulerar luftmotstånd och gör att svängningarna gradvis minskar i storlek, precis som i verkligheten.
                        </p>
                    </div>
                </div>
            `;

            document.getElementById('controls-container').innerHTML = controlsHTML;
        }

        // Fast value update - directly update DOM without re-rendering
        function updateValueDisplays() {
            const container = document.getElementById('controls-container');

            // Update all value displays
            const lengthDisplay = container.querySelector('#length-slider').parentElement.querySelector('span');
            if (lengthDisplay) lengthDisplay.textContent = params.length.toFixed(2).replace('.', ',') + ' m';

            const gravityDisplay = container.querySelector('#gravity-slider').parentElement.querySelector('span');
            if (gravityDisplay) gravityDisplay.textContent = params.gravity.toFixed(2).replace('.', ',') + ' m/s²';

            const massDisplay = container.querySelector('#mass-slider').parentElement.querySelector('span');
            if (massDisplay) massDisplay.textContent = (params.mass * 1000).toFixed(0) + ' g';

            const angleDisplay = container.querySelector('#angle-slider').parentElement.querySelector('span');
            if (angleDisplay) angleDisplay.textContent = params.initialAngle.toFixed(2).replace('.', ',') + ' °';

            const dampingDisplay = container.querySelector('#damping-slider').parentElement.querySelector('span');
            if (dampingDisplay) dampingDisplay.textContent = params.damping.toFixed(2).replace('.', ',');

            // Update calculated period
            const period = 2 * Math.PI * Math.sqrt(params.length / params.gravity);
            const periodDisplay = container.querySelector('.text-4xl.font-mono.font-bold.text-blue-600');
            if (periodDisplay) periodDisplay.textContent = period.toFixed(3).replace('.', ',') + ' s';
        }

        // Setup event listeners using event delegation - only runs once
        document.getElementById('controls-container').addEventListener('input', (e) => {
            if (e.target.id === 'length-slider') {
                params.length = parseFloat(e.target.value);
                scene.remove(labStand);
                labStand = createLabStand(params.length);
                scene.add(labStand);
                createPendulum(params.length, params.mass);
                updateCameraTarget();
                updateAngleVisuals();
                updateValueDisplays();
            } else if (e.target.id === 'gravity-slider') {
                params.gravity = parseFloat(e.target.value);
                updateValueDisplays();
            } else if (e.target.id === 'mass-slider') {
                params.mass = parseFloat(e.target.value) / 1000;
                createPendulum(params.length, params.mass);
                updateValueDisplays();
            } else if (e.target.id === 'angle-slider') {
                params.initialAngle = parseFloat(e.target.value);
                updateAngleVisuals();
                updateValueDisplays();
            } else if (e.target.id === 'damping-slider') {
                params.damping = parseFloat(e.target.value);
                updateValueDisplays();
            }
        });

        document.getElementById('controls-container').addEventListener('click', (e) => {
            if (e.target.id === 'start-button' || e.target.closest('#start-button')) {
                if (params.initialAngle >= 0.5 && simulationState === 'idle') {
                    simulationState = 'running';
                    timer = 0;
                    timeRef = 0;
                    swingCount = 0;
                    swingCountRef = 0;
                    measuredPeriod = null;
                    updateAngleVisuals(); // Clear angle visuals when starting
                    renderUI();
                }
            } else if (e.target.id === 'reset-button' || e.target.closest('#reset-button')) {
                simulationState = 'idle';
                timer = 0;
                timeRef = 0;
                swingCount = 0;
                swingCountRef = 0;
                measuredPeriod = null;
                params.initialAngle = 0;
                updateAngleVisuals();
                renderUI();
            } else if (e.target.closest('.celestial-button')) {
                const button = e.target.closest('.celestial-button');
                if (!button.disabled) {
                    params.gravity = parseFloat(button.dataset.gravity);
                    renderUI();
                }
            }
        });

        renderUI();
    </script>
</body>
</html>
