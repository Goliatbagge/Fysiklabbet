<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coulombs lag - Fysiklabbet</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }
        .glass-card-light {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }
        .slider-custom {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #ef4444, #64748b 50%, #38bdf8);
            outline: none;
        }
        .slider-custom::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f8fafc;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        .slider-custom::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f8fafc;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        .formula-box {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // Coulombs konstant
        const K = 8.99e9; // N·m²/C²

        const formatNumber = (num, decimals = 2) => {
            return num.toFixed(decimals).replace('.', ',');
        };

        const formatScientific = (num) => {
            if (num === 0) return '0';
            const exp = Math.floor(Math.log10(Math.abs(num)));
            const mantissa = num / Math.pow(10, exp);
            return `${formatNumber(mantissa, 2)} × 10^${exp}`;
        };

        const CoulombSimulation = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [charge1, setCharge1] = useState(2); // µC
            const [charge2, setCharge2] = useState(-3); // µC
            const [showCalculation, setShowCalculation] = useState(false);
            const [pos1, setPos1] = useState({ x: 200, y: 250 });
            const [pos2, setPos2] = useState({ x: 500, y: 250 });
            const [dragging, setDragging] = useState(null);
            const [distance, setDistance] = useState(0);
            const [force, setForce] = useState(0);

            const CHARGE_RADIUS = 35;
            const PIXELS_PER_CM = 50; // 50 pixlar = 1 cm

            // Beräkna avstånd och kraft
            useEffect(() => {
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const distPx = Math.sqrt(dx * dx + dy * dy);
                const distM = (distPx / PIXELS_PER_CM) / 100; // Konvertera till meter
                setDistance(distM);

                if (distM > 0) {
                    const q1 = charge1 * 1e-6; // Konvertera µC till C
                    const q2 = charge2 * 1e-6;
                    const f = K * Math.abs(q1 * q2) / (distM * distM);
                    setForce(f);
                }
            }, [pos1, pos2, charge1, charge2]);

            const handleMouseDown = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const dist1 = Math.sqrt((x - pos1.x) ** 2 + (y - pos1.y) ** 2);
                const dist2 = Math.sqrt((x - pos2.x) ** 2 + (y - pos2.y) ** 2);

                if (dist1 < CHARGE_RADIUS + 10) {
                    setDragging(1);
                } else if (dist2 < CHARGE_RADIUS + 10) {
                    setDragging(2);
                }
            }, [pos1, pos2]);

            const handleMouseMove = useCallback((e) => {
                if (!dragging || !canvasRef.current) return;

                const rect = canvasRef.current.getBoundingClientRect();
                let x = Math.max(CHARGE_RADIUS, Math.min(rect.width - CHARGE_RADIUS, e.clientX - rect.left));
                let y = Math.max(CHARGE_RADIUS, Math.min(rect.height - CHARGE_RADIUS, e.clientY - rect.top));

                // Förhindra överlappning
                const otherPos = dragging === 1 ? pos2 : pos1;
                const dx = x - otherPos.x;
                const dy = y - otherPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = CHARGE_RADIUS * 2 + 10;

                if (dist < minDist && dist > 0) {
                    // Flytta bort från den andra laddningen
                    const pushX = (dx / dist) * minDist;
                    const pushY = (dy / dist) * minDist;
                    x = otherPos.x + pushX;
                    y = otherPos.y + pushY;
                    // Håll inom canvas
                    x = Math.max(CHARGE_RADIUS, Math.min(rect.width - CHARGE_RADIUS, x));
                    y = Math.max(CHARGE_RADIUS, Math.min(rect.height - CHARGE_RADIUS, y));
                }

                if (dragging === 1) {
                    setPos1({ x, y });
                } else {
                    setPos2({ x, y });
                }
            }, [dragging, pos1, pos2]);

            const handleMouseUp = useCallback(() => {
                setDragging(null);
            }, []);

            const handleTouchStart = useCallback((e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const dist1 = Math.sqrt((x - pos1.x) ** 2 + (y - pos1.y) ** 2);
                const dist2 = Math.sqrt((x - pos2.x) ** 2 + (y - pos2.y) ** 2);

                if (dist1 < CHARGE_RADIUS + 20) {
                    setDragging(1);
                } else if (dist2 < CHARGE_RADIUS + 20) {
                    setDragging(2);
                }
            }, [pos1, pos2]);

            const handleTouchMove = useCallback((e) => {
                if (!dragging || !canvasRef.current) return;
                e.preventDefault();

                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                let x = Math.max(CHARGE_RADIUS, Math.min(rect.width - CHARGE_RADIUS, touch.clientX - rect.left));
                let y = Math.max(CHARGE_RADIUS, Math.min(rect.height - CHARGE_RADIUS, touch.clientY - rect.top));

                // Förhindra överlappning
                const otherPos = dragging === 1 ? pos2 : pos1;
                const dx = x - otherPos.x;
                const dy = y - otherPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = CHARGE_RADIUS * 2 + 10;

                if (dist < minDist && dist > 0) {
                    const pushX = (dx / dist) * minDist;
                    const pushY = (dy / dist) * minDist;
                    x = otherPos.x + pushX;
                    y = otherPos.y + pushY;
                    x = Math.max(CHARGE_RADIUS, Math.min(rect.width - CHARGE_RADIUS, x));
                    y = Math.max(CHARGE_RADIUS, Math.min(rect.height - CHARGE_RADIUS, y));
                }

                if (dragging === 1) {
                    setPos1({ x, y });
                } else {
                    setPos2({ x, y });
                }
            }, [dragging, pos1, pos2]);

            // Rita canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;

                // Rensa canvas
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, width, height);

                // Bakgrundseffekt
                const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.6);
                bgGradient.addColorStop(0, 'rgba(10, 30, 60, 0.4)');
                bgGradient.addColorStop(1, 'rgba(5, 5, 16, 0)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, width, height);

                // Rutnät (subtilt)
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x < width; x += PIXELS_PER_CM) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += PIXELS_PER_CM) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Beräkna kraftriktning
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const dirX = dist > 0 ? dx / dist : 1;
                const dirY = dist > 0 ? dy / dist : 0;

                // Bestäm om attraktion eller repulsion
                const isAttraction = (charge1 > 0 && charge2 < 0) || (charge1 < 0 && charge2 > 0);

                // Skala kraftvektorn för visualisering (linjär skala - proportionell mot kraften)
                // Referens: 1 N = 15 pixlar, max 120 pixlar, min 15 pixlar
                const PIXELS_PER_NEWTON = 15;
                const forceScale = Math.min(120, Math.max(15, force * PIXELS_PER_NEWTON));

                // Rita kraftvektorer
                const drawArrow = (fromX, fromY, toX, toY, color) => {
                    const headLen = 12;
                    const angle = Math.atan2(toY - fromY, toX - fromX);

                    // Glöd
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = color;

                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = 3;

                    // Linje
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();

                    // Pilhuvud
                    ctx.beginPath();
                    ctx.moveTo(toX, toY);
                    ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 0;
                };

                // Kraftvektorer för laddning 1
                if (charge1 !== 0 && charge2 !== 0 && dist > CHARGE_RADIUS * 2) {
                    const f1DirX = isAttraction ? dirX : -dirX;
                    const f1DirY = isAttraction ? dirY : -dirY;
                    drawArrow(
                        pos1.x + f1DirX * (CHARGE_RADIUS + 5),
                        pos1.y + f1DirY * (CHARGE_RADIUS + 5),
                        pos1.x + f1DirX * (CHARGE_RADIUS + forceScale),
                        pos1.y + f1DirY * (CHARGE_RADIUS + forceScale),
                        '#fbbf24'
                    );

                    // Kraftvektor för laddning 2 (motsatt riktning)
                    const f2DirX = isAttraction ? -dirX : dirX;
                    const f2DirY = isAttraction ? -dirY : dirY;
                    drawArrow(
                        pos2.x + f2DirX * (CHARGE_RADIUS + 5),
                        pos2.y + f2DirY * (CHARGE_RADIUS + 5),
                        pos2.x + f2DirX * (CHARGE_RADIUS + forceScale),
                        pos2.y + f2DirY * (CHARGE_RADIUS + forceScale),
                        '#fbbf24'
                    );
                }

                // Rita laddning 1
                const drawCharge = (x, y, charge, labelVar, labelValue) => {
                    const isPositive = charge > 0;
                    const color = isPositive ? '#ef4444' : '#38bdf8';
                    const glowColor = isPositive ? 'rgba(239, 68, 68, 0.6)' : 'rgba(56, 189, 248, 0.6)';

                    // Glöd
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = glowColor;

                    // Gradient för laddningen
                    const gradient = ctx.createRadialGradient(x - 10, y - 10, 5, x, y, CHARGE_RADIUS);
                    gradient.addColorStop(0, isPositive ? '#fca5a5' : '#7dd3fc');
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, isPositive ? '#991b1b' : '#0369a1');

                    ctx.beginPath();
                    ctx.arc(x, y, CHARGE_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.strokeStyle = isPositive ? '#fecaca' : '#bae6fd';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.shadowBlur = 0;

                    // Plus eller minus tecken
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 28px Poppins, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isPositive ? '+' : '−', x, y);

                    // Etikett - variabel i kursiv, värde i normal stil
                    ctx.textBaseline = 'top';

                    // Mät bredderna först
                    ctx.font = 'italic 18px Poppins, sans-serif';
                    const varWidth = ctx.measureText(labelVar).width;
                    ctx.font = '18px Poppins, sans-serif';
                    const eqValueWidth = ctx.measureText(' = ' + labelValue).width;
                    const totalWidth = varWidth + eqValueWidth;

                    // Centrera hela texten
                    const startX = x - totalWidth / 2;

                    // Variabel (kursiv)
                    ctx.fillStyle = isPositive ? '#fca5a5' : '#7dd3fc';
                    ctx.font = 'italic 18px Poppins, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(labelVar, startX, y + CHARGE_RADIUS + 14);

                    // Värde (normal)
                    ctx.fillStyle = '#cbd5e1';
                    ctx.font = '18px Poppins, sans-serif';
                    ctx.fillText(' = ' + labelValue, startX + varWidth, y + CHARGE_RADIUS + 14);
                };

                drawCharge(pos1.x, pos1.y, charge1, 'Q₁', `${formatNumber(charge1, 1)} µC`);
                drawCharge(pos2.x, pos2.y, charge2, 'Q₂', `${formatNumber(charge2, 1)} µC`);

                // Rita avståndslinje
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pos1.x, pos1.y);
                ctx.lineTo(pos2.x, pos2.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Avståndstext
                const midX = (pos1.x + pos2.x) / 2;
                const midY = (pos1.y + pos2.y) / 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const distCm = distance * 100;
                // Variabel r i kursiv
                ctx.fillStyle = '#a5b4fc';
                ctx.font = 'italic 17px Poppins, sans-serif';
                ctx.fillText('r', midX - 35, midY - 12);
                // Värde i normal stil
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '17px Poppins, sans-serif';
                ctx.fillText(` = ${formatNumber(distCm, 1)} cm`, midX + 5, midY - 12);

            }, [pos1, pos2, charge1, charge2, force, distance]);

            // Hantera resize
            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current && canvasRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        canvasRef.current.width = rect.width;
                        canvasRef.current.height = rect.height;
                    }
                };

                window.addEventListener('resize', handleResize);
                setTimeout(handleResize, 0);

                return () => window.removeEventListener('resize', handleResize);
            }, []);

            return (
                <div className="dark-container min-h-screen">
                    <div className="max-w-6xl mx-auto py-8 px-4">
                        {/* Header */}
                        <header className="text-center mb-8">
                            <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-cyan-400 tracking-tight glow-text mb-4">
                                Coulombs lag
                            </h1>
                            <p className="text-slate-400 max-w-2xl mx-auto leading-relaxed">
                                Utforska den elektriska kraften mellan två laddningar. Dra laddningarna för att ändra avståndet och använd glidarna för att justera laddningarnas storlek.
                            </p>
                        </header>

                        {/* Simulation */}
                        <div className="glass-card rounded-2xl p-4 mb-6">
                            <div
                                ref={containerRef}
                                className="relative w-full cursor-grab active:cursor-grabbing"
                                style={{ minHeight: '450px' }}
                            >
                                <canvas
                                    ref={canvasRef}
                                    className="block touch-none"
                                    style={{ width: '100%', height: '100%' }}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    onTouchStart={handleTouchStart}
                                    onTouchMove={handleTouchMove}
                                    onTouchEnd={handleMouseUp}
                                />
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                            <div className="glass-card-light p-5 rounded-xl">
                                <h3 className="text-slate-200 font-semibold mb-4 flex items-center gap-2">
                                    <span className="w-4 h-4 rounded-full bg-red-500"></span>
                                    Laddning Q₁
                                </h3>
                                <input
                                    type="range"
                                    min="-10"
                                    max="10"
                                    step="0.5"
                                    value={charge1}
                                    onChange={(e) => setCharge1(parseFloat(e.target.value))}
                                    className="w-full slider-custom"
                                />
                                <div className="flex justify-between text-sm text-slate-400 mt-2">
                                    <span>-10 µC</span>
                                    <span className={`font-semibold ${charge1 >= 0 ? 'text-red-400' : 'text-cyan-400'}`}>
                                        {formatNumber(charge1, 1)} µC
                                    </span>
                                    <span>+10 µC</span>
                                </div>
                            </div>

                            <div className="glass-card-light p-5 rounded-xl">
                                <h3 className="text-slate-200 font-semibold mb-4 flex items-center gap-2">
                                    <span className="w-4 h-4 rounded-full bg-cyan-500"></span>
                                    Laddning Q₂
                                </h3>
                                <input
                                    type="range"
                                    min="-10"
                                    max="10"
                                    step="0.5"
                                    value={charge2}
                                    onChange={(e) => setCharge2(parseFloat(e.target.value))}
                                    className="w-full slider-custom"
                                />
                                <div className="flex justify-between text-sm text-slate-400 mt-2">
                                    <span>-10 µC</span>
                                    <span className={`font-semibold ${charge2 >= 0 ? 'text-red-400' : 'text-cyan-400'}`}>
                                        {formatNumber(charge2, 1)} µC
                                    </span>
                                    <span>+10 µC</span>
                                </div>
                            </div>
                        </div>

                        {/* Force display and calculation toggle */}
                        <div className="glass-card rounded-2xl p-6 mb-6">
                            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-4">
                                <div>
                                    <h3 className="text-slate-200 font-semibold text-lg">Elektrisk kraft</h3>
                                    <p className="text-3xl font-bold text-amber-400 glow-text">
                                        F = {force < 0.01 ? formatScientific(force) : formatNumber(force, 3)} N
                                    </p>
                                    <p className="text-slate-400 text-sm mt-1">
                                        {(charge1 > 0 && charge2 < 0) || (charge1 < 0 && charge2 > 0)
                                            ? 'Attraktiv kraft (olika tecken)'
                                            : 'Repulsiv kraft (samma tecken)'}
                                    </p>
                                </div>
                                <label className="flex items-center gap-3 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={showCalculation}
                                        onChange={(e) => setShowCalculation(e.target.checked)}
                                        className="w-5 h-5 rounded border-slate-600 bg-slate-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-slate-900"
                                    />
                                    <span className="text-slate-300">Visa beräkning av kraft</span>
                                </label>
                            </div>

                            {showCalculation && (
                                <div className="bg-slate-900/50 rounded-xl p-5 border border-slate-700">
                                    <h4 className="text-slate-300 font-semibold mb-4">Beräkning med Coulombs lag:</h4>

                                    <div className="space-y-4 text-slate-300">
                                        {/* Formel */}
                                        <div className="text-center py-4 bg-slate-800/50 rounded-lg">
                                            <div className="text-2xl font-serif">
                                                <span className="text-amber-400 italic">F</span>
                                                <span className="text-slate-400"> = </span>
                                                <span className="text-slate-400 italic">k</span>
                                                <span className="text-slate-400"> · </span>
                                                <span className="inline-block text-center">
                                                    <span className="block border-b-2 border-slate-500 px-3 pb-1">
                                                        <span className="text-red-400 italic">Q</span><sub className="text-red-400">1</sub>
                                                        <span className="text-slate-400"> · </span>
                                                        <span className="text-cyan-400 italic">Q</span><sub className="text-cyan-400">2</sub>
                                                    </span>
                                                    <span className="block pt-1 italic">r</span><sup>2</sup>
                                                </span>
                                            </div>
                                        </div>

                                        {/* Värden */}
                                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                                <span className="text-slate-500 block">k =</span>
                                                <span className="text-slate-300">8,99 × 10⁹ N·m²/C²</span>
                                            </div>
                                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                                <span className="text-red-400 block">Q₁ =</span>
                                                <span className="text-slate-300">{formatNumber(charge1, 1)} µC = {formatScientific(charge1 * 1e-6)} C</span>
                                            </div>
                                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                                <span className="text-cyan-400 block">Q₂ =</span>
                                                <span className="text-slate-300">{formatNumber(charge2, 1)} µC = {formatScientific(charge2 * 1e-6)} C</span>
                                            </div>
                                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                                <span className="text-slate-500 block">r =</span>
                                                <span className="text-slate-300">{formatNumber(distance * 100, 1)} cm = {formatNumber(distance, 4)} m</span>
                                            </div>
                                        </div>

                                        {/* Uträkning */}
                                        <div className="bg-slate-800/30 p-4 rounded-lg space-y-3">
                                            <div className="text-slate-400 text-sm">Insättning av värden:</div>
                                            <div className="font-mono text-base text-slate-300">
                                                <span className="text-amber-400 italic">F</span> = <span className="text-slate-400">k</span> · |<span className="text-red-400 italic">Q</span>₁| · |<span className="text-cyan-400 italic">Q</span>₂| / <span className="italic">r</span>²
                                            </div>
                                            <div className="font-mono text-base text-slate-300">
                                                <span className="text-amber-400 italic">F</span> = 8,99×10⁹ · |{formatScientific(charge1 * 1e-6)}| · |{formatScientific(charge2 * 1e-6)}| / ({formatNumber(distance, 4)})²
                                            </div>
                                            <div className="font-mono text-base text-slate-300">
                                                <span className="text-amber-400 italic">F</span> = 8,99×10⁹ · {formatScientific(Math.abs(charge1 * 1e-6))} · {formatScientific(Math.abs(charge2 * 1e-6))} / {formatScientific(distance * distance)}
                                            </div>
                                        </div>

                                        {/* Resultat */}
                                        <div className="text-center py-4 bg-amber-500/10 rounded-lg border border-amber-500/30">
                                            <span className="text-amber-400 font-bold text-2xl">
                                                <span className="italic">F</span> = {force < 0.01 ? formatScientific(force) : formatNumber(force, 3)} N
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Info cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-cyan-500/20 rounded-lg">
                                        <span className="text-cyan-400 text-xl font-bold">⚡</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Coulombs lag</h3>
                                        <p className="text-slate-400 text-sm">
                                            Beskriver kraften mellan två punktladdningar. Kraften är proportionell mot produkten av laddningarna och omvänt proportionell mot kvadraten på avståndet.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-amber-500/20 rounded-lg">
                                        <span className="text-amber-400 text-xl font-bold">↔</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Newtons tredje lag</h3>
                                        <p className="text-slate-400 text-sm">
                                            Krafterna är lika stora men motriktade. Båda laddningarna påverkar varandra med samma kraft, oavsett deras storlek.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<CoulombSimulation />);
    </script>
</body>
</html>
