<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elektrostatisk induktion (influens) - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }
        .glass-card-light {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }
        .btn-glow {
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
            transition: all 0.3s ease;
        }
        .btn-glow:hover {
            box-shadow: 0 0 30px rgba(56, 189, 248, 0.5);
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // Controls Component
        const Controls = ({ showCharges, onToggleCharges, onReset }) => {
            return (
                <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 flex gap-4 glass-card p-4 rounded-2xl z-10 w-11/12 max-w-md justify-center">
                    <button
                        onClick={onToggleCharges}
                        className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${
                            showCharges
                                ? 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/50 btn-glow'
                                : 'bg-slate-700/50 text-slate-300 border border-slate-600 hover:bg-slate-600/50'
                        }`}
                    >
                        {showCharges ? 'Dölj laddningar' : 'Visa laddningar'}
                    </button>

                    <button
                        onClick={onReset}
                        className="px-6 py-3 rounded-lg font-semibold bg-slate-700/50 text-slate-300 border border-slate-600 hover:bg-slate-600/50 transition-all duration-200"
                    >
                        Återställ
                    </button>
                </div>
            );
        };

        // SimulationCanvas Component
        const SimulationCanvas = ({ showCharges, resetSignal }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const showChargesRef = useRef(showCharges);

            useEffect(() => {
                showChargesRef.current = showCharges;
            }, [showCharges]);

            // Physics Constants
            const ROD_WIDTH = 120;
            const ROD_HEIGHT = 40;
            const CAN_RADIUS = 60;
            const FLOOR_Y_RATIO = 0.25; // Golv 25% från botten (75% ned på skärmen)

            const ATTRACTION_STRENGTH = 300000;
            const REPULSION_STRENGTH = 300000;
            const DAMPING = 0.96;

            const STATIC_FRICTION_THRESHOLD = 3.0;
            const CHARGE_SHIFT_FACTOR = 0.85;
            const ELECTRON_SMOOTHING = 0.15;

            const physicsState = useRef({
                canX: 0,
                canY: 0,
                canV: 0,
                canRotation: 0,
                rodX: 200,
                rodY: 200,
                electrons: [],
                lastTime: 0,
            });

            const initCharges = useCallback(() => {
                const particles = [];
                const rows = 4;
                const cols = 4;
                const step = (CAN_RADIUS * 1.4) / Math.max(rows, cols);

                let idCounter = 0;
                for (let r = -rows/2; r < rows/2; r++) {
                    for (let c = -cols/2; c < cols/2; c++) {
                        const x = (c + 0.5) * step;
                        const y = (r + 0.5) * step;

                        if (Math.sqrt(x*x + y*y) < CAN_RADIUS - 10) {
                            particles.push({
                                id: idCounter++,
                                basePosition: { x, y },
                                currentPosition: { x, y }
                            });
                        }
                    }
                }
                physicsState.current.electrons = particles;
            }, []);

            useEffect(() => {
                if (!containerRef.current) return;
                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;

                const floorY = height * (1 - FLOOR_Y_RATIO);
                const canY = floorY - CAN_RADIUS;

                const startCanX = width * 0.75;
                const startRodX = width * 0.15;
                const startRodY = canY;

                physicsState.current.canX = startCanX;
                physicsState.current.canY = canY;
                physicsState.current.canV = 0;
                physicsState.current.canRotation = 0;
                physicsState.current.rodX = startRodX;
                physicsState.current.rodY = startRodY;
                physicsState.current.lastTime = 0;

                initCharges();
            }, [resetSignal, initCharges]);

            const handleInput = useCallback((clientX, clientY) => {
                if (!canvasRef.current) return;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                physicsState.current.rodX = Math.max(ROD_WIDTH/2, Math.min(rect.width - ROD_WIDTH/2, x));
                physicsState.current.rodY = Math.max(ROD_HEIGHT/2, Math.min(rect.height - ROD_HEIGHT/2, y));
            }, []);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const onMouseMove = (e) => handleInput(e.clientX, e.clientY);
                const onTouchMove = (e) => {
                    e.preventDefault();
                    handleInput(e.touches[0].clientX, e.touches[0].clientY);
                };
                const onMouseDown = (e) => handleInput(e.clientX, e.clientY);

                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('touchmove', onTouchMove, { passive: false });
                canvas.addEventListener('mousedown', onMouseDown);

                return () => {
                    canvas.removeEventListener('mousemove', onMouseMove);
                    canvas.removeEventListener('touchmove', onTouchMove);
                    canvas.removeEventListener('mousedown', onMouseDown);
                };
            }, [handleInput]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                let animationFrameId;

                const render = (time) => {
                    const { width, height } = canvas;
                    const state = physicsState.current;

                    if (width === 0 || height === 0) {
                        animationFrameId = requestAnimationFrame(render);
                        return;
                    }

                    if (!Number.isFinite(state.canX)) state.canX = width * 0.75;
                    if (!Number.isFinite(state.canV)) state.canV = 0;
                    if (!Number.isFinite(state.rodX)) state.rodX = width * 0.15;

                    const floorY = height * (1 - FLOOR_Y_RATIO);
                    const canY = floorY - CAN_RADIUS;
                    if (!Number.isFinite(state.rodY)) state.rodY = canY;

                    if (state.lastTime === 0) {
                        state.lastTime = time;
                    }

                    let deltaTime = (time - state.lastTime) / 1000;
                    state.lastTime = time;

                    if (deltaTime < 0 || deltaTime > 0.1) {
                        deltaTime = 0.016;
                    }

                    const rodY = state.rodY;

                    // 2D distance and direction from rod to can
                    const distVectorX = state.canX - state.rodX;
                    const distVectorY = canY - rodY;
                    const dist = Math.sqrt(distVectorX * distVectorX + distVectorY * distVectorY);
                    const effDist = Math.max(dist, ROD_WIDTH/2 + CAN_RADIUS + 5);

                    // Normalized direction (from rod toward can)
                    const dirX = dist > 0 ? distVectorX / dist : 1;
                    const dirY = dist > 0 ? distVectorY / dist : 0;

                    const inductionStrength = Math.min(30000 / (effDist * effDist), 1);

                    state.electrons.forEach(p => {
                        const cos = Math.cos(state.canRotation);
                        const sin = Math.sin(state.canRotation);

                        const rotX = p.basePosition.x * cos - p.basePosition.y * sin;
                        const rotY = p.basePosition.x * sin + p.basePosition.y * cos;

                        // Electrons move away from rod in 2D direction
                        let targetX = rotX + (dirX * inductionStrength * CAN_RADIUS * CHARGE_SHIFT_FACTOR);
                        let targetY = rotY + (dirY * inductionStrength * CAN_RADIUS * CHARGE_SHIFT_FACTOR);

                        const d = Math.sqrt(targetX*targetX + targetY*targetY);
                        if (d > CAN_RADIUS - 12) {
                            const scale = (CAN_RADIUS - 12) / d;
                            targetX *= scale;
                            targetY *= scale;
                        }

                        p.currentPosition.x += (targetX - p.currentPosition.x) * ELECTRON_SMOOTHING;
                        p.currentPosition.y += (targetY - p.currentPosition.y) * ELECTRON_SMOOTHING;
                    });

                    let netForce = 0;
                    state.electrons.forEach(p => {
                        const cos = Math.cos(state.canRotation);
                        const sin = Math.sin(state.canRotation);
                        const pX = state.canX + (p.basePosition.x * cos - p.basePosition.y * sin);
                        const pY = canY + (p.basePosition.x * sin + p.basePosition.y * cos);

                        const eX = state.canX + p.currentPosition.x;
                        const eY = canY + p.currentPosition.y;

                        const dpX = pX - state.rodX;
                        const dpY = pY - rodY;
                        const distP2 = Math.max(dpX*dpX + dpY*dpY, 200);
                        const distP = Math.sqrt(distP2);
                        const dirPx = (state.rodX - pX) / distP;

                        const forceProton = (ATTRACTION_STRENGTH / distP2) * dirPx;

                        const deX = eX - state.rodX;
                        const deY = eY - rodY;
                        const distE2 = Math.max(deX*deX + deY*deY, 200);
                        const distE = Math.sqrt(distE2);
                        const dirEx = (state.rodX - eX) / distE;

                        const forceElectron = -(REPULSION_STRENGTH / distE2) * dirEx;

                        netForce += (forceProton + forceElectron);
                    });

                    if (Math.abs(state.canV) < 2.0 && Math.abs(netForce) < STATIC_FRICTION_THRESHOLD) {
                        netForce = 0;
                        state.canV = 0;
                    }

                    const acceleration = netForce;
                    state.canV += acceleration * deltaTime;
                    state.canV *= DAMPING;

                    // 2D collision detection between rod and can
                    const collisionDistX = state.canX - state.rodX;
                    const collisionDistY = canY - rodY;
                    const collisionDist = Math.sqrt(collisionDistX * collisionDistX + collisionDistY * collisionDistY);
                    const minDist = ROD_WIDTH/2 + CAN_RADIUS;

                    // Only apply collision if actually close in 2D space
                    if (collisionDist < minDist && collisionDist > 0) {
                        // Push can away from rod
                        const pushX = (collisionDistX / collisionDist) * (minDist - collisionDist);
                        state.canX += pushX;

                        // Stop velocity if moving toward rod
                        if ((collisionDistX > 0 && state.canV < 0) || (collisionDistX < 0 && state.canV > 0)) {
                            state.canV = 0;
                        }
                    }

                    state.canX += state.canV * deltaTime;

                    const dx = state.canV * deltaTime;
                    state.canRotation += dx / CAN_RADIUS;

                    // Dark background
                    ctx.fillStyle = '#050510';
                    ctx.fillRect(0, 0, width, height);

                    // Subtle gradient overlay
                    const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.7);
                    bgGradient.addColorStop(0, 'rgba(10, 30, 60, 0.3)');
                    bgGradient.addColorStop(1, 'rgba(5, 5, 16, 0)');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, width, height);

                    // Floor line with glow
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(56, 189, 248, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, floorY);
                    ctx.lineTo(width, floorY);
                    ctx.strokeStyle = '#334155';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Ebonite rod (dark with negative charge glow)
                    const rodGradient = ctx.createLinearGradient(state.rodX - ROD_WIDTH/2, 0, state.rodX + ROD_WIDTH/2, 0);
                    rodGradient.addColorStop(0, '#1e293b');
                    rodGradient.addColorStop(0.3, '#334155');
                    rodGradient.addColorStop(0.5, '#475569');
                    rodGradient.addColorStop(0.7, '#334155');
                    rodGradient.addColorStop(1, '#1e293b');

                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(56, 189, 248, 0.3)';
                    ctx.fillStyle = rodGradient;
                    if (ctx.roundRect) {
                        ctx.beginPath();
                        ctx.roundRect(state.rodX - ROD_WIDTH/2, rodY - ROD_HEIGHT/2, ROD_WIDTH, ROD_HEIGHT, 8);
                        ctx.fill();
                        ctx.strokeStyle = '#64748b';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        ctx.fillRect(state.rodX - ROD_WIDTH/2, rodY - ROD_HEIGHT/2, ROD_WIDTH, ROD_HEIGHT);
                    }
                    ctx.shadowBlur = 0;

                    // Negative charges on rod with cyan glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(56, 189, 248, 0.9)';
                    ctx.fillStyle = '#38bdf8';
                    ctx.font = 'bold 24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    for(let i=1; i<4; i++) {
                        const rx = state.rodX - ROD_WIDTH/2 + (i * ROD_WIDTH/4);
                        ctx.fillText('−', rx, rodY);
                    }
                    ctx.shadowBlur = 0;

                    // Aluminum can with metallic gradient
                    ctx.save();
                    ctx.translate(state.canX, canY);
                    ctx.rotate(state.canRotation);

                    // Metallic can gradient
                    const gradient = ctx.createRadialGradient(-20, -20, 10, 0, 0, CAN_RADIUS);
                    gradient.addColorStop(0, '#94a3b8');
                    gradient.addColorStop(0.3, '#64748b');
                    gradient.addColorStop(0.6, '#475569');
                    gradient.addColorStop(1, '#334155');

                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(56, 189, 248, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 0, CAN_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.strokeStyle = '#94a3b8';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Inner ring highlight
                    ctx.beginPath();
                    ctx.arc(0, 0, CAN_RADIUS - 5, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Handle/tab on can
                    ctx.fillStyle = '#64748b';
                    ctx.beginPath();
                    ctx.ellipse(CAN_RADIUS * 0.4, 0, 10, 15, 0, 0, Math.PI*2);
                    ctx.fill();

                    if (showChargesRef.current) {
                        // Positive charges (protons) with red glow
                        state.electrons.forEach(p => {
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = 'rgba(239, 68, 68, 0.8)';
                            ctx.fillStyle = '#ef4444';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('+', p.basePosition.x, p.basePosition.y);
                        });
                        ctx.shadowBlur = 0;
                    }
                    ctx.restore();

                    if (showChargesRef.current) {
                        ctx.save();
                        ctx.translate(state.canX, canY);
                        // Negative charges (electrons) with cyan glow
                        state.electrons.forEach(p => {
                            // Outer glow
                            const outerGlow = ctx.createRadialGradient(p.currentPosition.x, p.currentPosition.y, 0, p.currentPosition.x, p.currentPosition.y, 15);
                            outerGlow.addColorStop(0, 'rgba(56, 189, 248, 0.6)');
                            outerGlow.addColorStop(0.5, 'rgba(14, 165, 233, 0.2)');
                            outerGlow.addColorStop(1, 'rgba(2, 132, 199, 0)');
                            ctx.beginPath();
                            ctx.arc(p.currentPosition.x, p.currentPosition.y, 15, 0, Math.PI * 2);
                            ctx.fillStyle = outerGlow;
                            ctx.fill();

                            // Core
                            ctx.shadowBlur = 12;
                            ctx.shadowColor = 'rgba(56, 189, 248, 0.9)';
                            ctx.fillStyle = '#38bdf8';
                            ctx.font = 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('−', p.currentPosition.x, p.currentPosition.y);
                        });
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }

                    animationFrameId = requestAnimationFrame(render);
                };

                animationFrameId = requestAnimationFrame(render);

                return () => {
                    cancelAnimationFrame(animationFrameId);
                };
            }, [resetSignal, initCharges]);

            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current && canvasRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        canvasRef.current.width = rect.width;
                        canvasRef.current.height = rect.height;

                        if (!Number.isFinite(physicsState.current.canX) || physicsState.current.canX > rect.width + 200 || physicsState.current.canX < -200) {
                            physicsState.current.canX = rect.width * 0.75;
                            physicsState.current.rodX = rect.width * 0.15;
                        }
                    }
                };

                window.addEventListener('resize', handleResize);
                // Initial resize with a small delay to ensure container is rendered
                setTimeout(handleResize, 0);

                return () => window.removeEventListener('resize', handleResize);
            }, []);

            return (
                <div ref={containerRef} className="absolute inset-0 cursor-move">
                    <div className="absolute top-4 left-0 w-full text-center pointer-events-none select-none z-0">
                        <h2 className="text-slate-500 text-sm font-medium">
                            Flytta staven med musen eller fingret
                        </h2>
                    </div>
                    <canvas
                        ref={canvasRef}
                        className="block touch-none"
                        style={{ width: '100%', height: '100%', boxShadow: '0 0 40px rgba(56, 189, 248, 0.1), inset 0 0 60px rgba(0, 0, 0, 0.5)' }}
                    />
                </div>
            );
        };

        // App Component
        function App() {
            const [showCharges, setShowCharges] = useState(true);
            const [resetSignal, setResetSignal] = useState(0);

            const handleToggleCharges = () => setShowCharges(prev => !prev);
            const handleReset = () => setResetSignal(prev => prev + 1);

            return (
                <div className="dark-container min-h-screen">
                    <div className="max-w-6xl mx-auto py-8 px-4">
                        {/* Header */}
                        <header className="text-center mb-8">
                            <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-cyan-400 tracking-tight glow-text mb-4">
                                Elektrostatisk induktion
                            </h1>
                            <p className="text-slate-400 max-w-2xl mx-auto leading-relaxed">
                                Observera hur den neutrala aluminiumburken attraheras av den negativt laddade ebonitstaven.
                                Elektronerna repelleras, vilket skapar en dipol som får burken att rulla.
                            </p>
                        </header>

                        {/* Main simulation area */}
                        <div className="glass-card rounded-2xl p-4 mb-6">
                            <div className="relative w-full" style={{ minHeight: '500px', maxHeight: '600px' }}>
                                <SimulationCanvas
                                    showCharges={showCharges}
                                    resetSignal={resetSignal}
                                />

                                <Controls
                                    showCharges={showCharges}
                                    onToggleCharges={handleToggleCharges}
                                    onReset={handleReset}
                                />
                            </div>
                        </div>

                        {/* Info cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-cyan-500/20 rounded-lg">
                                        <span className="text-cyan-400 text-xl font-bold">−</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Ebonitstav</h3>
                                        <p className="text-slate-400 text-sm">Negativt laddad efter att ha gnidits mot päls. De negativa laddningarna repellerar elektronerna i burken.</p>
                                    </div>
                                </div>
                            </div>
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-cyan-500/20 rounded-lg">
                                        <span className="text-cyan-400 text-xl font-bold">⚡</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Influens</h3>
                                        <p className="text-slate-400 text-sm">Elektronerna i burken flyttar sig bort från staven, vilket skapar en positiv sida närmast staven som attraheras.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
    </script>
</body>
</html>