<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magdeburgska halvkloten - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }
        .glass-card-light {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }
        .btn-glow {
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
            transition: all 0.3s ease;
        }
        .btn-glow:hover {
            box-shadow: 0 0 30px rgba(56, 189, 248, 0.5);
        }
        .btn-danger-glow {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
        }
        .btn-danger-glow:hover {
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        }
        .slider-glow::-webkit-slider-thumb {
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
        }
        input[type="range"] {
            -webkit-appearance: none;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 8px;
            height: 8px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #38bdf8, #0ea5e9);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.6);
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.9);
        }
        .pulse-glow {
            animation: pulseGlow 2s ease-in-out infinite;
        }
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(56, 189, 248, 0.4); }
            50% { box-shadow: 0 0 40px rgba(56, 189, 248, 0.8); }
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <main class="dark-container min-h-screen">
        <div id="root"></div>
    </main>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ===== TYPES & CONSTANTS =====
        const SimulationState = {
            SEALED: 'SEALED',
            PUMPING: 'PUMPING',
            LEAKING: 'LEAKING',
            SEPARATED: 'SEPARATED',
        };

        const SPHERE_RADIUS = 120;
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 400;
        // Beräkna partiklar baserat på area för samma koncentration
        const CANVAS_AREA = CANVAS_WIDTH * CANVAS_HEIGHT;
        const SPHERE_AREA_PX = Math.PI * SPHERE_RADIUS * SPHERE_RADIUS;
        const OUTSIDE_AREA = CANVAS_AREA - SPHERE_AREA_PX;
        const MAX_PARTICLES_OUTSIDE = 150;
        const MAX_PARTICLES_INSIDE = Math.round(MAX_PARTICLES_OUTSIDE * (SPHERE_AREA_PX / OUTSIDE_AREA));
        const FORCE_PER_HORSE = 800;
        const SPHERE_AREA = 0.2;
        const ATM_PRESSURE_PA = 101325;

        // ===== ICON COMPONENTS =====
        const Info = ({ size = 16, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
        );

        const Gauge = ({ size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 2v4"></path>
                <path d="m6.8 15-3.5 2"></path>
                <path d="m20.7 7-3.5 2"></path>
                <path d="M6.8 9 3.3 7"></path>
                <path d="m20.7 17-3.5-2"></path>
                <path d="m9 22 3-8 3 8"></path>
                <circle cx="12" cy="12" r="10"></circle>
            </svg>
        );

        const Wind = ({ size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>
            </svg>
        );

        const Settings2 = ({ size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M20 7h-9"></path>
                <path d="M14 17H5"></path>
                <circle cx="17" cy="17" r="3"></circle>
                <circle cx="7" cy="7" r="3"></circle>
            </svg>
        );

        const RotateCcw = ({ size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );

        const RotateCw = ({ size = 20, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        );

        // ===== SIMULATION CANVAS COMPONENT =====
        const SimulationCanvas = ({ simulationState, internalPressure, separationDistance, setInternalPressure, width, height, showForceArrows, showPullForces, pullingForce }) => {
            const canvasRef = useRef(null);
            const particlesInsideRef = useRef([]);
            const particlesOutsideRef = useRef([]);
            const requestRef = useRef();

            const createParticle = (isInside, startX, startY, initialVx, initialVy) => {
                let x, y, vx, vy;

                if (startX !== undefined && startY !== undefined) {
                    x = startX;
                    y = startY;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    if (isInside) {
                        const r = Math.sqrt(Math.random()) * (SPHERE_RADIUS - 10);
                        x = width / 2 + r * Math.cos(angle);
                        y = height / 2 + r * Math.sin(angle);
                    } else {
                        x = Math.random() * width;
                        y = Math.random() * height;
                        const dx = x - width / 2;
                        const dy = y - height / 2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < SPHERE_RADIUS + 10) {
                            const pushRatio = (SPHERE_RADIUS + 20) / dist;
                            x = width / 2 + dx * pushRatio;
                            y = height / 2 + dy * pushRatio;
                        }
                    }
                }

                if (initialVx !== undefined && initialVy !== undefined) {
                    vx = initialVx;
                    vy = initialVy;
                } else {
                    const vAngle = Math.random() * Math.PI * 2;
                    const vSpeed = 2 + Math.random() * 3;
                    vx = Math.cos(vAngle) * vSpeed;
                    vy = Math.sin(vAngle) * vSpeed;
                }

                return {
                    x, y, vx, vy,
                    radius: 1.5,
                    isInside,
                    pulseOffset: Math.random() * Math.PI * 2,
                };
            };

            useEffect(() => {
                if (particlesInsideRef.current.length === 0) {
                    for (let i = 0; i < MAX_PARTICLES_INSIDE; i++) {
                        particlesInsideRef.current.push(createParticle(true));
                    }
                    for (let i = 0; i < MAX_PARTICLES_OUTSIDE; i++) {
                        particlesOutsideRef.current.push(createParticle(false));
                    }
                }
            }, [width, height]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const centerX = width / 2;
                const centerY = height / 2;
                const hoseY = centerY + SPHERE_RADIUS;
                const hoseWidth = 30;
                const hoseHeight = 100;
                let time = 0;

                const update = () => {
                    time += 0.02;

                    // Clear with dark background
                    ctx.fillStyle = '#050510';
                    ctx.fillRect(0, 0, width, height);

                    // Add subtle gradient overlay
                    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, width * 0.7);
                    bgGradient.addColorStop(0, 'rgba(10, 30, 60, 0.3)');
                    bgGradient.addColorStop(1, 'rgba(5, 5, 16, 0)');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, width, height);

                    const isSealed = simulationState === SimulationState.SEALED;
                    const isPumping = simulationState === SimulationState.PUMPING;
                    const isLeaking = simulationState === SimulationState.LEAKING;
                    const isSeparated = simulationState === SimulationState.SEPARATED;

                    // --- Logic Updates ---
                    if (isPumping && !isSeparated) {
                        particlesInsideRef.current.forEach(p => {
                            if (p.y > centerY) {
                                const dx = centerX - p.x;
                                const dy = hoseY - p.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist > 0) {
                                    p.vx += (dx / dist) * 0.2;
                                    p.vy += (dy / dist) * 0.2;
                                }
                            }
                        });

                        for (let i = particlesInsideRef.current.length - 1; i >= 0; i--) {
                            const p = particlesInsideRef.current[i];
                            const distToHole = Math.sqrt((p.x - centerX) ** 2 + (p.y - hoseY) ** 2);
                            if (distToHole < 15) {
                                particlesInsideRef.current.splice(i, 1);
                            }
                        }
                    }

                    if ((isLeaking || isSeparated) && particlesInsideRef.current.length < MAX_PARTICLES_INSIDE) {
                        const particlesToSpawn = 3;
                        for (let k = 0; k < particlesToSpawn; k++) {
                            if (particlesInsideRef.current.length >= MAX_PARTICLES_INSIDE) break;
                            const spread = (Math.random() - 0.5) * 1.5;
                            const speed = 5 + Math.random() * 3;
                            particlesInsideRef.current.push(
                                createParticle(true, centerX, hoseY - 5, spread * 2, -speed)
                            );
                        }
                    }

                    const currentPressure = particlesInsideRef.current.length / MAX_PARTICLES_INSIDE;
                    if (Math.abs(currentPressure - internalPressure) > 0.01) {
                        setInternalPressure(currentPressure);
                    }

                    // --- Draw Hose ---
                    if (!isSeparated) {
                        // Metallic hose
                        const hoseGradient = ctx.createLinearGradient(centerX - hoseWidth/2, 0, centerX + hoseWidth/2, 0);
                        hoseGradient.addColorStop(0, '#1e293b');
                        hoseGradient.addColorStop(0.3, '#334155');
                        hoseGradient.addColorStop(0.5, '#475569');
                        hoseGradient.addColorStop(0.7, '#334155');
                        hoseGradient.addColorStop(1, '#1e293b');
                        ctx.fillStyle = hoseGradient;
                        ctx.fillRect(centerX - hoseWidth/2, hoseY - 5, hoseWidth, hoseHeight);

                        // Hose glow when pumping
                        if (isPumping && particlesInsideRef.current.length > 0) {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#f97316';
                            for(let i=0; i<5; i++) {
                                if(Math.random() > 0.5) {
                                    const px = centerX + (Math.random() - 0.5) * (hoseWidth - 8);
                                    const py = hoseY + Math.random() * hoseHeight;
                                    ctx.beginPath();
                                    ctx.arc(px, py, 3, 0, Math.PI*2);
                                    ctx.fillStyle = '#fb923c';
                                    ctx.fill();
                                }
                            }
                            ctx.shadowBlur = 0;
                        }
                        if (isLeaking) {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#38bdf8';
                            for(let i=0; i<5; i++) {
                                if(Math.random() > 0.5) {
                                    const px = centerX + (Math.random() - 0.5) * (hoseWidth - 8);
                                    const py = hoseY + Math.random() * hoseHeight;
                                    ctx.beginPath();
                                    ctx.arc(px, py, 3, 0, Math.PI*2);
                                    ctx.fillStyle = '#7dd3fc';
                                    ctx.fill();
                                }
                            }
                            ctx.shadowBlur = 0;
                        }
                    }

                    // --- Draw Sphere Halves (Modern metallic style) ---
                    const leftX = centerX - separationDistance / 2;
                    const rightX = centerX + separationDistance / 2;

                    // Draw function for hemisphere with metallic gradient
                    const drawHemisphere = (x, isLeft) => {
                        ctx.save();

                        // Main hemisphere gradient
                        const grad = ctx.createRadialGradient(
                            x + (isLeft ? -30 : 30), centerY - 30, 10,
                            x, centerY, SPHERE_RADIUS
                        );
                        grad.addColorStop(0, '#64748b');
                        grad.addColorStop(0.3, '#475569');
                        grad.addColorStop(0.6, '#334155');
                        grad.addColorStop(1, '#1e293b');

                        ctx.beginPath();
                        if (isLeft) {
                            ctx.arc(x, centerY, SPHERE_RADIUS, Math.PI / 2, -Math.PI / 2, false);
                        } else {
                            ctx.arc(x, centerY, SPHERE_RADIUS, -Math.PI / 2, Math.PI / 2, false);
                        }
                        ctx.closePath();
                        ctx.fillStyle = grad;
                        ctx.fill();

                        // Metallic rim
                        ctx.strokeStyle = '#94a3b8';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        // Inner glow/shadow
                        ctx.beginPath();
                        if (isLeft) {
                            ctx.arc(x, centerY, SPHERE_RADIUS - 5, Math.PI / 2, -Math.PI / 2, false);
                        } else {
                            ctx.arc(x, centerY, SPHERE_RADIUS - 5, -Math.PI / 2, Math.PI / 2, false);
                        }
                        ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.restore();
                    };

                    drawHemisphere(leftX, true);
                    drawHemisphere(rightX, false);

                    // Flanges with metallic look
                    const drawFlange = (x, y) => {
                        const flangeGrad = ctx.createLinearGradient(x - 12, y - 12, x + 12, y + 12);
                        flangeGrad.addColorStop(0, '#64748b');
                        flangeGrad.addColorStop(0.5, '#94a3b8');
                        flangeGrad.addColorStop(1, '#475569');
                        ctx.fillStyle = flangeGrad;
                        ctx.fillRect(x - 12, y - 12, 24, 24);
                        ctx.strokeStyle = '#cbd5e1';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - 12, y - 12, 24, 24);
                    };

                    drawFlange(leftX, centerY - SPHERE_RADIUS);
                    drawFlange(leftX, centerY + SPHERE_RADIUS);
                    drawFlange(rightX, centerY - SPHERE_RADIUS);
                    drawFlange(rightX, centerY + SPHERE_RADIUS);

                    // Draw Ropes with subtle glow
                    const ropeWidth = 6;
                    const ropeLength = 80;

                    const drawRope = (startX, endX) => {
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(180, 140, 80, 0.5)';

                        ctx.strokeStyle = '#92400e';
                        ctx.lineWidth = ropeWidth;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(startX, centerY);
                        ctx.lineTo(endX, centerY);
                        ctx.stroke();

                        ctx.strokeStyle = '#b45309';
                        ctx.lineWidth = ropeWidth * 0.5;
                        const segments = 5;
                        const segmentLength = (endX - startX) / segments;
                        for (let i = 0; i < segments; i++) {
                            ctx.beginPath();
                            const sx = startX + i * segmentLength;
                            ctx.moveTo(sx, centerY - 2);
                            ctx.lineTo(sx + segmentLength * 0.5, centerY + 2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                    };

                    drawRope(leftX - SPHERE_RADIUS, leftX - SPHERE_RADIUS - ropeLength);
                    drawRope(rightX + SPHERE_RADIUS, rightX + SPHERE_RADIUS + ropeLength);

                    // --- Draw Pull Forces on Ropes ---
                    if (showPullForces && pullingForce > 0) {
                        const maxForce = 15000;
                        const forceRatio = Math.min(pullingForce / maxForce, 1);
                        const arrowLength = 20 + forceRatio * 50;

                        const drawPullArrow = (startX, direction) => {
                            const tipX = startX + direction * arrowLength;
                            const y = centerY;

                            ctx.shadowBlur = 12;
                            ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';

                            // Arrow line
                            ctx.beginPath();
                            ctx.moveTo(startX, y);
                            ctx.lineTo(tipX, y);
                            ctx.strokeStyle = '#22c55e';
                            ctx.lineWidth = 4;
                            ctx.stroke();

                            // Arrow head
                            const headLen = 10;
                            ctx.beginPath();
                            ctx.moveTo(tipX, y);
                            ctx.lineTo(tipX - direction * headLen, y - 6);
                            ctx.lineTo(tipX - direction * headLen, y + 6);
                            ctx.closePath();
                            ctx.fillStyle = '#22c55e';
                            ctx.fill();

                            ctx.shadowBlur = 0;
                        };

                        // Left pull arrow (pointing left)
                        drawPullArrow(leftX - SPHERE_RADIUS - ropeLength - 10, -1);
                        // Right pull arrow (pointing right)
                        drawPullArrow(rightX + SPHERE_RADIUS + ropeLength + 10, 1);
                    }

                    // --- Draw Glowing Particles ---
                    const drawGlowingParticle = (p) => {
                        const baseRadius = p.radius;

                        // Outer glow - cyan/blue for all particles
                        const outerGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, baseRadius * 8);
                        outerGlow.addColorStop(0, 'rgba(56, 189, 248, 0.6)');
                        outerGlow.addColorStop(0.3, 'rgba(14, 165, 233, 0.3)');
                        outerGlow.addColorStop(0.6, 'rgba(2, 132, 199, 0.1)');
                        outerGlow.addColorStop(1, 'rgba(2, 132, 199, 0)');

                        ctx.beginPath();
                        ctx.arc(p.x, p.y, baseRadius * 8, 0, Math.PI * 2);
                        ctx.fillStyle = outerGlow;
                        ctx.fill();

                        // Inner bright core
                        const coreGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, baseRadius * 2);
                        coreGlow.addColorStop(0, '#f0f9ff');
                        coreGlow.addColorStop(0.5, '#7dd3fc');
                        coreGlow.addColorStop(1, '#38bdf8');

                        ctx.beginPath();
                        ctx.arc(p.x, p.y, baseRadius * 2, 0, Math.PI * 2);
                        ctx.fillStyle = coreGlow;
                        ctx.fill();
                    };

                    // --- Particle Physics ---
                    const updateParticle = (p, isFromInsideList) => {
                        p.x += p.vx;
                        p.y += p.vy;

                        const speedSq = p.vx * p.vx + p.vy * p.vy;
                        if (speedSq > 30) {
                            p.vx *= 0.98;
                            p.vy *= 0.98;
                        }

                        if (p.x < 0 || p.x > width) p.vx *= -1;
                        if (p.y < 0 || p.y > height) p.vy *= -1;

                        if (isSeparated) {
                            // Left Hemisphere Interaction
                            if (p.x < leftX) {
                                const dx = p.x - leftX;
                                const dy = p.y - centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    const dot = p.vx * nx + p.vy * ny;

                                    if (dist < SPHERE_RADIUS && dot > 0 && dist > SPHERE_RADIUS - 5) {
                                        p.vx -= 2 * dot * nx;
                                        p.vy -= 2 * dot * ny;
                                        p.x = leftX + nx * (SPHERE_RADIUS - 5.1);
                                        p.y = centerY + ny * (SPHERE_RADIUS - 5.1);
                                    } else if (dist > SPHERE_RADIUS && dot < 0 && dist < SPHERE_RADIUS + 5) {
                                        p.vx -= 2 * dot * nx;
                                        p.vy -= 2 * dot * ny;
                                        p.x = leftX + nx * (SPHERE_RADIUS + 5.1);
                                        p.y = centerY + ny * (SPHERE_RADIUS + 5.1);
                                    }
                                }
                            }

                            // Right Hemisphere Interaction
                            if (p.x > rightX) {
                                const dx = p.x - rightX;
                                const dy = p.y - centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    const dot = p.vx * nx + p.vy * ny;

                                    if (dist < SPHERE_RADIUS && dot > 0 && dist > SPHERE_RADIUS - 5) {
                                        p.vx -= 2 * dot * nx;
                                        p.vy -= 2 * dot * ny;
                                        p.x = rightX + nx * (SPHERE_RADIUS - 5.1);
                                        p.y = centerY + ny * (SPHERE_RADIUS - 5.1);
                                    } else if (dist > SPHERE_RADIUS && dot < 0 && dist < SPHERE_RADIUS + 5) {
                                        p.vx -= 2 * dot * nx;
                                        p.vy -= 2 * dot * ny;
                                        p.x = rightX + nx * (SPHERE_RADIUS + 5.1);
                                        p.y = centerY + ny * (SPHERE_RADIUS + 5.1);
                                    }
                                }
                            }
                        } else {
                            if (isFromInsideList) {
                                const distC = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
                                if (distC > SPHERE_RADIUS - 5) {
                                    const inHoleZone = isPumping && Math.abs(p.x - centerX) < 15 && p.y > centerY + SPHERE_RADIUS - 20;
                                    if (!inHoleZone) {
                                        const nx = (p.x - centerX) / distC;
                                        const ny = (p.y - centerY) / distC;
                                        const dot = p.vx * nx + p.vy * ny;
                                        if (dot > 0) {
                                            p.vx = p.vx - 2 * dot * nx;
                                            p.vy = p.vy - 2 * dot * ny;
                                            const jitter = (Math.random() - 0.5) * 0.5;
                                            p.vx += jitter;
                                            p.vy -= jitter;
                                        }
                                        p.x = centerX + (SPHERE_RADIUS - 5.1) * nx;
                                        p.y = centerY + (SPHERE_RADIUS - 5.1) * ny;
                                    }
                                }
                            } else {
                                const dxL = p.x - leftX;
                                const dy = p.y - centerY;
                                const distL = Math.sqrt(dxL * dxL + dy * dy);
                                if (distL < SPHERE_RADIUS + 5) {
                                    const angle = Math.atan2(dy, dxL);
                                    const nx = Math.cos(angle);
                                    const ny = Math.sin(angle);
                                    const dot = p.vx * nx + p.vy * ny;
                                    if (dot < 0) {
                                        p.vx = p.vx - 2 * dot * nx;
                                        p.vy = p.vy - 2 * dot * ny;
                                    }
                                }
                                const distR = Math.sqrt((p.x - rightX) ** 2 + dy * dy);
                                if (distR < SPHERE_RADIUS + 5) {
                                    const angle = Math.atan2(dy, p.x - rightX);
                                    const nx = Math.cos(angle);
                                    const ny = Math.sin(angle);
                                    const dot = p.vx * nx + p.vy * ny;
                                    if (dot < 0) {
                                        p.vx = p.vx - 2 * dot * nx;
                                        p.vy = p.vy - 2 * dot * ny;
                                    }
                                }
                            }
                        }
                    };

                    // Update and draw all particles
                    particlesOutsideRef.current.forEach(p => {
                        updateParticle(p, false);
                        drawGlowingParticle(p);
                    });

                    particlesInsideRef.current.forEach(p => {
                        updateParticle(p, true);
                        drawGlowingParticle(p);
                    });

                    // Particle-Particle Collisions
                    for (let i = 0; i < particlesInsideRef.current.length; i++) {
                        for (let j = i + 1; j < particlesInsideRef.current.length; j++) {
                            const p1 = particlesInsideRef.current[i];
                            const p2 = particlesInsideRef.current[j];
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = p1.radius + p2.radius;

                            if (dist < minDist && dist > 0) {
                                const nx = dx / dist;
                                const ny = dy / dist;
                                const dvx = p2.vx - p1.vx;
                                const dvy = p2.vy - p1.vy;
                                const dvn = dvx * nx + dvy * ny;

                                if (dvn < 0) {
                                    p1.vx += dvn * nx;
                                    p1.vy += dvn * ny;
                                    p2.vx -= dvn * nx;
                                    p2.vy -= dvn * ny;
                                    const overlap = minDist - dist;
                                    p1.x -= overlap * nx * 0.5;
                                    p1.y -= overlap * ny * 0.5;
                                    p2.x += overlap * nx * 0.5;
                                    p2.y += overlap * ny * 0.5;
                                }
                            }
                        }
                    }

                    // --- Force Arrows with Glow ---
                    if (showForceArrows) {
                        const drawForceArrow = (tipX, tipY, angle, length, isExternal) => {
                            if (length < 5) return;

                            const tailX = tipX - Math.cos(angle) * length;
                            const tailY = tipY - Math.sin(angle) * length;

                            ctx.shadowBlur = 10;
                            ctx.shadowColor = isExternal ? 'rgba(56, 189, 248, 0.8)' : 'rgba(249, 115, 22, 0.8)';

                            ctx.beginPath();
                            ctx.moveTo(tailX, tailY);
                            ctx.lineTo(tipX, tipY);
                            ctx.strokeStyle = isExternal ? '#38bdf8' : '#f97316';
                            ctx.lineWidth = 3;
                            ctx.stroke();

                            const headLen = 8;
                            ctx.beginPath();
                            ctx.moveTo(tipX, tipY);
                            ctx.lineTo(tipX - headLen * Math.cos(angle - Math.PI / 6), tipY - headLen * Math.sin(angle - Math.PI / 6));
                            ctx.lineTo(tipX - headLen * Math.cos(angle + Math.PI / 6), tipY - headLen * Math.sin(angle + Math.PI / 6));
                            ctx.closePath();
                            ctx.fillStyle = isExternal ? '#38bdf8' : '#f97316';
                            ctx.fill();

                            ctx.shadowBlur = 0;
                        };

                        const arrowScale = 45;
                        const internalForceLen = arrowScale * internalPressure;

                        const drawArrowPair = (x, y, normalAngle) => {
                            drawForceArrow(x, y, normalAngle, arrowScale, true);
                            drawForceArrow(x, y, normalAngle + Math.PI, internalForceLen, false);
                        };

                        // Arrow pairs on hemispheres
                        drawArrowPair(leftX, centerY - SPHERE_RADIUS, Math.PI / 2);
                        drawArrowPair(leftX - SPHERE_RADIUS, centerY, 0);
                        drawArrowPair(leftX + SPHERE_RADIUS * Math.cos(Math.PI * 1.25), centerY + SPHERE_RADIUS * Math.sin(Math.PI * 1.25), Math.PI * 0.25);
                        drawArrowPair(leftX + SPHERE_RADIUS * Math.cos(Math.PI * 0.75), centerY + SPHERE_RADIUS * Math.sin(Math.PI * 0.75), Math.PI * -0.25);
                        drawArrowPair(leftX, centerY + SPHERE_RADIUS, -Math.PI / 2);

                        drawArrowPair(rightX + SPHERE_RADIUS, centerY, Math.PI);
                        drawArrowPair(rightX, centerY - SPHERE_RADIUS, Math.PI / 2);
                        drawArrowPair(rightX, centerY + SPHERE_RADIUS, -Math.PI / 2);
                        drawArrowPair(rightX + SPHERE_RADIUS * Math.cos(-Math.PI * 0.25), centerY + SPHERE_RADIUS * Math.sin(-Math.PI * 0.25), Math.PI * 0.75);
                        drawArrowPair(rightX + SPHERE_RADIUS * Math.cos(Math.PI * 0.25), centerY + SPHERE_RADIUS * Math.sin(Math.PI * 0.25), Math.PI * 1.25);
                    }

                    requestRef.current = requestAnimationFrame(update);
                };

                requestRef.current = requestAnimationFrame(update);
                return () => {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, [width, height, simulationState, internalPressure, separationDistance, setInternalPressure, showForceArrows, showPullForces, pullingForce]);

            return (
                <canvas
                    ref={canvasRef}
                    width={width}
                    height={height}
                    className="rounded-xl block mx-auto"
                    style={{ boxShadow: '0 0 40px rgba(56, 189, 248, 0.15), inset 0 0 60px rgba(0, 0, 0, 0.5)' }}
                />
            );
        };

        // ===== PRESSURE GAUGE COMPONENT =====
        const PressureGauge = ({ value, label }) => {
            const angle = -90 + (value * 180);

            return (
                <div className="flex flex-col items-center justify-center p-4 glass-card-light rounded-xl w-full">
                    <div className="relative w-32 h-16 overflow-hidden mb-2">
                        <div className="absolute top-0 left-0 w-32 h-32 rounded-full border-[10px] border-slate-600 box-border"
                             style={{ boxShadow: 'inset 0 0 20px rgba(0,0,0,0.5)' }}></div>
                        <div
                            className="absolute bottom-0 left-1/2 w-1 h-14 origin-bottom transform -translate-x-1/2 transition-transform duration-300 ease-out"
                            style={{
                                transform: `translateX(-50%) rotate(${angle}deg)`,
                                background: 'linear-gradient(to top, #38bdf8, #0ea5e9)',
                                boxShadow: '0 0 10px rgba(56, 189, 248, 0.8)'
                            }}
                        ></div>
                        <div className="absolute bottom-0 left-1/2 w-4 h-4 rounded-full -translate-x-1/2 translate-y-1/2"
                             style={{ background: 'linear-gradient(135deg, #64748b, #334155)' }}></div>
                    </div>
                    <div className="flex justify-between w-32 text-xs text-slate-400 font-mono mt-1 px-1">
                        <span>0</span>
                        <span>50</span>
                        <span>100</span>
                    </div>
                    <span className="text-sm font-semibold text-slate-300 mt-2">{label}</span>
                    <span className="text-lg font-mono text-cyan-400 glow-text">
                        {(value * 101.3).toFixed(1).replace('.', ',')} kPa
                    </span>
                </div>
            );
        };

        // ===== CONTROLS COMPONENT =====
        const Controls = ({ simulationState, onTogglePump, onOpenValve, pullingForce, setPullingForce, requiredForce, onReset }) => {
            const isPumping = simulationState === SimulationState.PUMPING;
            const isSealed = simulationState === SimulationState.SEALED;
            const isSeparated = simulationState === SimulationState.SEPARATED;
            const equivalentHorses = (pullingForce / FORCE_PER_HORSE).toFixed(1);
            const isForceSufficient = pullingForce > requiredForce;
            const forceIntensity = Math.min((pullingForce / 15000) * 100, 100);

            return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 w-full max-w-4xl">

                    {/* Experiment Controls */}
                    <div className="glass-card p-6 rounded-xl flex flex-col gap-4">
                        <div className="flex items-center gap-2 mb-2">
                            <Settings2 size={20} className="text-cyan-400" />
                            <h2 className="text-lg font-bold text-slate-200">Experimentkontroller</h2>
                        </div>

                        <div className="flex gap-3">
                            <button
                                onClick={onTogglePump}
                                disabled={isSeparated}
                                className={`flex-1 py-3 px-4 rounded-lg font-medium transition-all flex items-center justify-center gap-2 ${
                                    isPumping
                                        ? 'bg-orange-500/20 text-orange-400 border border-orange-500/50 btn-danger-glow'
                                        : 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/50 btn-glow hover:bg-cyan-500/30'
                                } ${isSeparated ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <Wind size={20} className={isPumping ? 'animate-spin' : ''} />
                                {isPumping ? 'Stoppa pumpen' : 'Starta vakuumpump'}
                            </button>

                            <button
                                onClick={onOpenValve}
                                disabled={isPumping || (!isSealed && !isSeparated)}
                                className="flex-1 py-3 px-4 bg-slate-700/50 text-slate-300 border border-slate-600 rounded-lg font-medium hover:bg-slate-600/50 transition-colors flex items-center justify-center gap-2 disabled:opacity-40 disabled:cursor-not-allowed"
                            >
                                <RotateCcw size={20} />
                                Öppna ventil
                            </button>
                        </div>

                        <p className="text-sm text-slate-500">
                            När ventilen öppnas strömmar luft in igen och trycket utjämnas.
                        </p>
                    </div>

                    {/* Pulling Force Control */}
                    <div className="glass-card p-6 rounded-xl flex flex-col gap-4"
                         style={{
                             borderColor: forceIntensity > 60 ? `rgba(249, 115, 22, ${forceIntensity / 200})` : 'rgba(56, 189, 248, 0.15)',
                             boxShadow: forceIntensity > 60 ? `0 0 ${forceIntensity / 3}px rgba(249, 115, 22, ${forceIntensity / 300})` : 'none'
                         }}>
                        <div className="flex items-center gap-2 mb-2">
                            <svg className="w-6 h-6 text-orange-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <path d="M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" />
                                <circle cx="5" cy="17" r="2" />
                                <circle cx="19" cy="17" r="2" />
                            </svg>
                            <h2 className="text-lg font-bold text-slate-200">Dragkraft</h2>
                        </div>

                        {/* Strain Indicator Bar */}
                        <div className="relative w-full h-3 bg-slate-800 rounded-full overflow-hidden border border-slate-700">
                            <div
                                className="absolute top-0 left-0 h-full transition-all duration-300 ease-out rounded-full"
                                style={{
                                    width: `${forceIntensity}%`,
                                    background: `linear-gradient(90deg, #38bdf8, ${forceIntensity > 50 ? '#f97316' : '#0ea5e9'}, ${forceIntensity > 80 ? '#ef4444' : '#38bdf8'})`,
                                    boxShadow: `0 0 10px ${forceIntensity > 60 ? 'rgba(249, 115, 22, 0.6)' : 'rgba(56, 189, 248, 0.6)'}`
                                }}
                            ></div>
                        </div>

                        <div className="space-y-4">
                            <div className="flex justify-between items-center">
                                <label className="text-sm font-medium text-slate-400">
                                    Dragkraft: <span className="text-orange-400 font-bold text-lg">{pullingForce.toLocaleString('sv-SE')} N</span>
                                </label>
                                <span className="text-xs text-slate-500">≈ {equivalentHorses.replace('.', ',')} hästar</span>
                            </div>

                            <input
                                type="range"
                                min="0"
                                max="15000"
                                step="100"
                                value={pullingForce}
                                onChange={(e) => setPullingForce(parseInt(e.target.value))}
                                className="w-full cursor-pointer"
                            />

                            <div className="flex justify-between text-xs text-slate-500">
                                <span>0 N</span>
                                <span>15 000 N</span>
                            </div>

                            {/* Force Status Indicator */}
                            <div className={`p-3 rounded-lg text-center font-medium transition-all border ${
                                isForceSufficient
                                    ? 'bg-emerald-500/20 text-emerald-400 border-emerald-500/50'
                                    : 'bg-red-500/20 text-red-400 border-red-500/50'
                            }`}>
                                {isForceSufficient ? (
                                    <span>✓ Kraften räcker! Kloten är isär</span>
                                ) : (
                                    <span>✗ För svagt! Behöver {Math.ceil((requiredForce - pullingForce) / 100) * 100} N till</span>
                                )}
                            </div>

                            <p className="text-xs text-slate-500 text-center">
                                Dra i glidaren för att öka dragkraften. När kraften överstiger {(requiredForce / 1000).toFixed(1).replace('.', ',')} kN lossnar kloten automatiskt!
                            </p>

                            {isSeparated && (
                                <button
                                    onClick={onReset}
                                    className="w-full py-3 rounded-lg font-bold text-white transition-transform active:scale-95 flex items-center justify-center gap-2 bg-emerald-600/80 hover:bg-emerald-500/80 border border-emerald-500/50"
                                    style={{ boxShadow: '0 0 20px rgba(52, 211, 153, 0.3)' }}
                                >
                                    <RotateCw size={20} />
                                    Sätt ihop kloten
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // ===== MAIN APP COMPONENT =====
        const App = () => {
            const [simulationState, setSimulationState] = useState(SimulationState.SEALED);
            const [internalPressure, setInternalPressure] = useState(1.0);
            const [pullingForce, setPullingForce] = useState(0);
            const [separationDistance, setSeparationDistance] = useState(0);
            const [targetSeparation, setTargetSeparation] = useState(0);
            const [showForceArrows, setShowForceArrows] = useState(true);
            const [showPullForces, setShowPullForces] = useState(true);
            const animationRef = useRef(null);

            const calculateNetForce = () => {
                const pressureDiff = (1.0 - internalPressure) * ATM_PRESSURE_PA;
                return pressureDiff * SPHERE_AREA;
            };

            const handleTogglePump = () => {
                if (simulationState === SimulationState.PUMPING) {
                    setSimulationState(SimulationState.SEALED);
                } else {
                    setSimulationState(SimulationState.PUMPING);
                }
            };

            const handleOpenValve = () => {
                setSimulationState(SimulationState.LEAKING);
                setTargetSeparation(0);
            };

            const handleReset = () => {
                setPullingForce(0);
                setSimulationState(SimulationState.SEALED);
                setInternalPressure(1.0);
                setTargetSeparation(0);
            };

            useEffect(() => {
                if (simulationState === SimulationState.LEAKING && internalPressure >= 0.98) {
                    setInternalPressure(1.0);
                    setSimulationState(SimulationState.SEALED);
                    setTargetSeparation(0);
                }
            }, [internalPressure, simulationState]);

            useEffect(() => {
                const animate = () => {
                    setSeparationDistance(current => {
                        const diff = targetSeparation - current;
                        if (Math.abs(diff) < 1) return targetSeparation;
                        return current + diff * 0.15;
                    });
                    animationRef.current = requestAnimationFrame(animate);
                };
                animationRef.current = requestAnimationFrame(animate);
                return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); };
            }, [targetSeparation]);

            useEffect(() => {
                if (simulationState === SimulationState.LEAKING) return;
                const holdingForce = calculateNetForce();

                if (pullingForce > holdingForce) {
                    if (simulationState !== SimulationState.SEPARATED) {
                        setSimulationState(SimulationState.SEPARATED);
                        setTargetSeparation(200);
                        setInternalPressure(1.0);
                    }
                } else {
                    if (simulationState === SimulationState.SEPARATED) {
                        setSimulationState(SimulationState.SEALED);
                        setTargetSeparation(0);
                    }
                }
            }, [pullingForce, internalPressure, simulationState]);

            return (
                <div className="min-h-screen flex flex-col items-center py-8 px-4 gap-8 max-w-6xl mx-auto">

                    {/* Header */}
                    <header className="text-center space-y-3">
                        <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-cyan-400 tracking-tight glow-text">
                            Magdeburgska halvkloten
                        </h1>
                        <p className="text-slate-400 max-w-2xl mx-auto leading-relaxed">
                            Ett berömt experiment från 1654 av Otto von Guericke. När luften pumpas ut ur klotet skapas ett vakuum.
                            Lufttrycket utanför pressar då ihop halvkloten med en enorm kraft.
                        </p>
                    </header>

                    {/* Main Simulation Area */}
                    <div className="w-full flex flex-col lg:flex-row gap-6 items-start">

                        {/* Left: Canvas */}
                        <div className="flex-1 w-full glass-card p-4 rounded-2xl relative">
                            <div className="absolute top-6 left-6 z-10 glass-card-light p-3 rounded-lg text-xs space-y-2">
                                <div className="flex items-center gap-2">
                                    <span className="w-3 h-3 rounded-full bg-cyan-400" style={{ boxShadow: '0 0 8px rgba(56, 189, 248, 0.8)' }}></span>
                                    <span className="text-slate-300">Luftmolekyler</span>
                                </div>
                                <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={showForceArrows}
                                        onChange={(e) => setShowForceArrows(e.target.checked)}
                                        className="w-4 h-4 rounded border-slate-600 bg-slate-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0 cursor-pointer"
                                    />
                                    <span className="text-slate-300">Visa tryckkrafter</span>
                                </label>
                                <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={showPullForces}
                                        onChange={(e) => setShowPullForces(e.target.checked)}
                                        className="w-4 h-4 rounded border-slate-600 bg-slate-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-0 cursor-pointer"
                                    />
                                    <span className="text-slate-300">Visa dragkrafter</span>
                                </label>
                            </div>

                            <SimulationCanvas
                                width={600}
                                height={400}
                                simulationState={simulationState}
                                internalPressure={internalPressure}
                                setInternalPressure={setInternalPressure}
                                separationDistance={separationDistance}
                                showForceArrows={showForceArrows}
                                showPullForces={showPullForces}
                                pullingForce={pullingForce}
                            />

                            {/* Info overlay */}
                            <div className="mt-4 grid grid-cols-2 gap-4 text-sm">
                                <div className="flex items-start gap-2 glass-card-light p-3 rounded-lg">
                                    <div className="p-1.5 bg-cyan-500/20 rounded text-cyan-400 shrink-0"><Info size={16}/></div>
                                    <p className="text-slate-400"><strong className="text-cyan-400">Blå pilar:</strong> Atmosfärstrycket (konstant kraft inåt)</p>
                                </div>
                                <div className="flex items-start gap-2 glass-card-light p-3 rounded-lg">
                                    <div className="p-1.5 bg-orange-500/20 rounded text-orange-400 shrink-0"><Info size={16}/></div>
                                    <p className="text-slate-400"><strong className="text-orange-400">Röda pilar:</strong> Det inre gastrycket som minskar</p>
                                </div>
                            </div>
                        </div>

                        {/* Right: Data & Visuals */}
                        <div className="w-full lg:w-64 flex flex-col gap-4 shrink-0">
                            <div className="glass-card p-4 rounded-xl flex flex-col items-center">
                                <div className="flex items-center gap-2 text-slate-300 font-semibold mb-3">
                                    <Gauge size={20} className="text-cyan-400" />
                                    <span>Tryckmätare</span>
                                </div>
                                <PressureGauge value={internalPressure} label="Tryck inuti" />
                            </div>

                            <div className="glass-card p-4 rounded-xl text-sm space-y-3">
                                <h3 className="font-semibold text-slate-200">Aktuell data</h3>
                                <div className="flex justify-between border-b border-slate-700 pb-2">
                                    <span className="text-slate-500">Tryckskillnad:</span>
                                    <span className="font-mono text-cyan-400">{(101.3 * (1 - internalPressure)).toFixed(1).replace('.', ',')} kPa</span>
                                </div>
                                <div className="flex justify-between border-b border-slate-700 pb-2">
                                    <span className="text-slate-500">Nettokraft:</span>
                                    <span className="font-mono text-orange-400">{(calculateNetForce() / 1000).toFixed(1).replace('.', ',')} kN</span>
                                </div>
                                <div className="text-xs text-slate-500 italic pt-1">
                                    Kraften som krävs för att dra isär kloten.
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Controls Area */}
                    <Controls
                        simulationState={simulationState}
                        onTogglePump={handleTogglePump}
                        onOpenValve={handleOpenValve}
                        pullingForce={pullingForce}
                        setPullingForce={setPullingForce}
                        requiredForce={calculateNetForce()}
                        onReset={handleReset}
                    />
                </div>
            );
        };

        // ===== RENDER APP =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
