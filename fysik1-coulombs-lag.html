<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coulombs lag - Fysiklabbet</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }
        .glass-card-light {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }
        .slider-custom {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #ef4444, #64748b 50%, #38bdf8);
            outline: none;
        }
        .slider-custom::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f8fafc;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        .slider-custom::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f8fafc;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        .formula-box {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // KaTeX-komponent för att rendera LaTeX
        const Latex = ({ math, displayMode = false }) => {
            const containerRef = useRef(null);

            useEffect(() => {
                if (containerRef.current && window.katex) {
                    try {
                        window.katex.render(math, containerRef.current, {
                            throwOnError: false,
                            displayMode: displayMode,
                        });
                    } catch (e) {
                        containerRef.current.textContent = math;
                    }
                }
            }, [math, displayMode]);

            return <span ref={containerRef} />;
        };

        // Beräkningsvisning med KaTeX
        const CalculationDisplay = ({ charge1, charge2, distance, force, formatNumber }) => {
            const q1 = charge1 * 1e-6;
            const q2 = charge2 * 1e-6;
            const q1Exp = Math.floor(Math.log10(Math.abs(q1)));
            const q2Exp = Math.floor(Math.log10(Math.abs(q2)));
            const q1Mantissa = q1 / Math.pow(10, q1Exp);
            const q2Mantissa = q2 / Math.pow(10, q2Exp);
            const r2 = distance * distance;
            const r2Exp = Math.floor(Math.log10(r2));
            const r2Mantissa = r2 / Math.pow(10, r2Exp);

            const formatMantissa = (m) => m.toFixed(2).replace('.', ',');

            return (
                <div className="bg-slate-900/50 rounded-xl p-5 border border-slate-700">
                    <h4 className="text-slate-300 font-semibold mb-4">Beräkning med Coulombs lag:</h4>

                    <div className="space-y-4 text-slate-300">
                        {/* Huvudformel */}
                        <div className="text-center py-4 bg-slate-800/50 rounded-lg text-2xl">
                            <Latex math="F = k \cdot \frac{Q_1 \cdot Q_2}{r^2}" displayMode={true} />
                        </div>

                        {/* Värden */}
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                <div className="text-slate-400 mb-1"><Latex math="k =" /></div>
                                <div className="text-slate-300"><Latex math="8{,}99 \cdot 10^9 \, \mathrm{N{\cdot}m^2/C^2}" /></div>
                            </div>
                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                <div className="text-red-400 mb-1"><Latex math="Q_1 =" /></div>
                                <div className="text-slate-300">{formatNumber(charge1, 1)} µC</div>
                            </div>
                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                <div className="text-cyan-400 mb-1"><Latex math="Q_2 =" /></div>
                                <div className="text-slate-300">{formatNumber(charge2, 1)} µC</div>
                            </div>
                            <div className="bg-slate-800/30 p-3 rounded-lg">
                                <div className="text-slate-400 mb-1"><Latex math="r =" /></div>
                                <div className="text-slate-300">{formatNumber(distance * 100, 1)} cm = {formatNumber(distance, 4)} m</div>
                            </div>
                        </div>

                        {/* Uträkning */}
                        <div className="bg-slate-800/30 p-4 rounded-lg space-y-4">
                            <div className="text-slate-400 text-sm mb-2">Insättning av värden:</div>
                            <div className="text-lg overflow-x-auto">
                                <Latex
                                    math={`F = 8{,}99 \\cdot 10^9 \\cdot \\frac{|${formatMantissa(q1Mantissa)} \\cdot 10^{${q1Exp}}| \\cdot |${formatMantissa(q2Mantissa)} \\cdot 10^{${q2Exp}}|}{(${formatNumber(distance, 4)})^2}`}
                                    displayMode={true}
                                />
                            </div>
                            <div className="text-lg overflow-x-auto">
                                <Latex
                                    math={`F = 8{,}99 \\cdot 10^9 \\cdot \\frac{${formatMantissa(Math.abs(q1Mantissa))} \\cdot 10^{${q1Exp}} \\cdot ${formatMantissa(Math.abs(q2Mantissa))} \\cdot 10^{${q2Exp}}}{${formatMantissa(r2Mantissa)} \\cdot 10^{${r2Exp}}}`}
                                    displayMode={true}
                                />
                            </div>
                        </div>

                        {/* Resultat */}
                        <div className="text-center py-4 bg-amber-500/10 rounded-lg border border-amber-500/30">
                            <span className="text-amber-400 font-bold text-2xl">
                                <Latex math={`F = ${force < 0.01 ? (force.toExponential(2).replace('.', ',')) : formatNumber(force, 3)} \\, \\text{N}`} />
                            </span>
                        </div>
                    </div>
                </div>
            );
        };

        // Coulombs konstant
        const K = 8.99e9; // N·m²/C²

        const formatNumber = (num, decimals = 2) => {
            return num.toFixed(decimals).replace('.', ',');
        };

        const formatScientific = (num) => {
            if (num === 0) return '0';
            const exp = Math.floor(Math.log10(Math.abs(num)));
            const mantissa = num / Math.pow(10, exp);
            return `${formatNumber(mantissa, 2)} × 10^${exp}`;
        };

        const CoulombSimulation = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [charge1, setCharge1] = useState(5); // µC
            const [charge2, setCharge2] = useState(-5); // µC
            const [showCalculation, setShowCalculation] = useState(false);
            const [pos1, setPos1] = useState({ x: 275, y: 250 });
            const [pos2, setPos2] = useState({ x: 525, y: 250 });
            const [canvasReady, setCanvasReady] = useState(false);
            const [dragging, setDragging] = useState(null);
            const [clickStart, setClickStart] = useState(null);
            const [distance, setDistance] = useState(0);
            const [force, setForce] = useState(0);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const fullscreenRef = useRef(null);

            const MIN_CHARGE_RADIUS = 20;
            const MAX_CHARGE_RADIUS = 45;
            const PIXELS_PER_CM = 50; // 50 pixlar = 1 cm

            // Beräkna radie baserat på laddningens storlek
            const getChargeRadius = (charge) => {
                const absCharge = Math.abs(charge);
                return MIN_CHARGE_RADIUS + (MAX_CHARGE_RADIUS - MIN_CHARGE_RADIUS) * (absCharge / 10);
            };

            const charge1Radius = getChargeRadius(charge1);
            const charge2Radius = getChargeRadius(charge2);

            // Beräkna avstånd och kraft
            useEffect(() => {
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const distPx = Math.sqrt(dx * dx + dy * dy);
                const distM = (distPx / PIXELS_PER_CM) / 100; // Konvertera till meter
                setDistance(distM);

                if (distM > 0) {
                    const q1 = charge1 * 1e-6; // Konvertera µC till C
                    const q2 = charge2 * 1e-6;
                    const f = K * Math.abs(q1 * q2) / (distM * distM);
                    setForce(f);
                }
            }, [pos1, pos2, charge1, charge2]);

            const handleMouseDown = useCallback((e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const dist1 = Math.sqrt((x - pos1.x) ** 2 + (y - pos1.y) ** 2);
                const dist2 = Math.sqrt((x - pos2.x) ** 2 + (y - pos2.y) ** 2);

                if (dist1 < charge1Radius + 10) {
                    setDragging(1);
                    setClickStart({ x, y, charge: 1 });
                } else if (dist2 < charge2Radius + 10) {
                    setDragging(2);
                    setClickStart({ x, y, charge: 2 });
                } else {
                    setClickStart(null);
                }
            }, [pos1, pos2, charge1Radius, charge2Radius]);

            const handleMouseMove = useCallback((e) => {
                if (!dragging || !canvasRef.current) return;

                const rect = canvasRef.current.getBoundingClientRect();
                const myRadius = dragging === 1 ? charge1Radius : charge2Radius;
                const otherRadius = dragging === 1 ? charge2Radius : charge1Radius;
                let x = Math.max(myRadius, Math.min(rect.width - myRadius, e.clientX - rect.left));
                let y = Math.max(myRadius, Math.min(rect.height - myRadius, e.clientY - rect.top));

                // Förhindra överlappning
                const otherPos = dragging === 1 ? pos2 : pos1;
                const dx = x - otherPos.x;
                const dy = y - otherPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = myRadius + otherRadius + 10;

                if (dist < minDist && dist > 0) {
                    // Flytta bort från den andra laddningen
                    const pushX = (dx / dist) * minDist;
                    const pushY = (dy / dist) * minDist;
                    x = otherPos.x + pushX;
                    y = otherPos.y + pushY;
                    // Håll inom canvas
                    x = Math.max(myRadius, Math.min(rect.width - myRadius, x));
                    y = Math.max(myRadius, Math.min(rect.height - myRadius, y));
                }

                if (dragging === 1) {
                    setPos1({ x, y });
                } else {
                    setPos2({ x, y });
                }
            }, [dragging, pos1, pos2, charge1Radius, charge2Radius]);

            const handleMouseUp = useCallback((e) => {
                if (clickStart && canvasRef.current && e.clientX !== undefined) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const moveDistance = Math.sqrt((x - clickStart.x) ** 2 + (y - clickStart.y) ** 2);

                    // Om musen inte rört sig mer än 5 pixlar, räkna som klick
                    if (moveDistance < 5) {
                        if (clickStart.charge === 1) {
                            setCharge1(prev => -prev);
                        } else if (clickStart.charge === 2) {
                            setCharge2(prev => -prev);
                        }
                    }
                }
                setDragging(null);
                setClickStart(null);
            }, [clickStart]);

            const handleTouchStart = useCallback((e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const dist1 = Math.sqrt((x - pos1.x) ** 2 + (y - pos1.y) ** 2);
                const dist2 = Math.sqrt((x - pos2.x) ** 2 + (y - pos2.y) ** 2);

                if (dist1 < charge1Radius + 20) {
                    setDragging(1);
                    setClickStart({ x, y, charge: 1 });
                } else if (dist2 < charge2Radius + 20) {
                    setDragging(2);
                    setClickStart({ x, y, charge: 2 });
                } else {
                    setClickStart(null);
                }
            }, [pos1, pos2, charge1Radius, charge2Radius]);

            const handleTouchMove = useCallback((e) => {
                if (!dragging || !canvasRef.current) return;
                e.preventDefault();

                const touch = e.touches[0];
                const rect = canvasRef.current.getBoundingClientRect();
                const myRadius = dragging === 1 ? charge1Radius : charge2Radius;
                const otherRadius = dragging === 1 ? charge2Radius : charge1Radius;
                let x = Math.max(myRadius, Math.min(rect.width - myRadius, touch.clientX - rect.left));
                let y = Math.max(myRadius, Math.min(rect.height - myRadius, touch.clientY - rect.top));

                // Förhindra överlappning
                const otherPos = dragging === 1 ? pos2 : pos1;
                const dx = x - otherPos.x;
                const dy = y - otherPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = myRadius + otherRadius + 10;

                if (dist < minDist && dist > 0) {
                    const pushX = (dx / dist) * minDist;
                    const pushY = (dy / dist) * minDist;
                    x = otherPos.x + pushX;
                    y = otherPos.y + pushY;
                    x = Math.max(myRadius, Math.min(rect.width - myRadius, x));
                    y = Math.max(myRadius, Math.min(rect.height - myRadius, y));
                }

                if (dragging === 1) {
                    setPos1({ x, y });
                } else {
                    setPos2({ x, y });
                }
            }, [dragging, pos1, pos2, charge1Radius, charge2Radius]);

            const handleTouchEnd = useCallback((e) => {
                if (clickStart && e.changedTouches && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const moveDistance = Math.sqrt((x - clickStart.x) ** 2 + (y - clickStart.y) ** 2);

                    // Om fingret inte rört sig mer än 10 pixlar, räkna som tap
                    if (moveDistance < 10) {
                        if (clickStart.charge === 1) {
                            setCharge1(prev => -prev);
                        } else if (clickStart.charge === 2) {
                            setCharge2(prev => -prev);
                        }
                    }
                }
                setDragging(null);
                setClickStart(null);
            }, [clickStart]);

            // Fullskärmsfunktioner
            const toggleFullscreen = useCallback(() => {
                if (!document.fullscreenElement) {
                    fullscreenRef.current?.requestFullscreen?.();
                } else {
                    document.exitFullscreen?.();
                }
            }, []);

            useEffect(() => {
                const handleFullscreenChange = () => {
                    const wasFullscreen = isFullscreen;
                    const nowFullscreen = !!document.fullscreenElement;
                    setIsFullscreen(nowFullscreen);

                    // Trigga omritning av canvas när fullskärmsläge ändras
                    setTimeout(() => {
                        if (containerRef.current && canvasRef.current) {
                            const rect = containerRef.current.getBoundingClientRect();
                            canvasRef.current.width = rect.width;
                            canvasRef.current.height = rect.height;

                            // Om vi lämnar fullskärm, flytta tillbaka laddningarna så de syns
                            if (wasFullscreen && !nowFullscreen) {
                                const margin = MAX_CHARGE_RADIUS + 20;
                                const maxX = rect.width - margin;
                                const maxY = rect.height - margin;

                                setPos1(prev => ({
                                    x: Math.max(margin, Math.min(maxX, prev.x)),
                                    y: Math.max(margin, Math.min(maxY, prev.y))
                                }));
                                setPos2(prev => ({
                                    x: Math.max(margin, Math.min(maxX, prev.x)),
                                    y: Math.max(margin, Math.min(maxY, prev.y))
                                }));
                            }

                            setCanvasReady(prev => !prev);
                        }
                    }, 100);
                };

                document.addEventListener('fullscreenchange', handleFullscreenChange);
                return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
            }, [isFullscreen]);

            // Rita canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;

                // Rensa canvas
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, width, height);

                // Bakgrundseffekt
                const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width * 0.6);
                bgGradient.addColorStop(0, 'rgba(10, 30, 60, 0.4)');
                bgGradient.addColorStop(1, 'rgba(5, 5, 16, 0)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, width, height);

                // Rutnät (subtilt)
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x < width; x += PIXELS_PER_CM) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += PIXELS_PER_CM) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Beräkna kraftriktning
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const dirX = dist > 0 ? dx / dist : 1;
                const dirY = dist > 0 ? dy / dist : 0;

                // Bestäm om attraktion eller repulsion
                const isAttraction = (charge1 > 0 && charge2 < 0) || (charge1 < 0 && charge2 > 0);

                // Skala kraftvektorn för visualisering (linjär skala - strikt proportionell mot kraften)
                // 1 N = 0.5 pixlar, inget tak - pilarna är alltid proportionella
                const PIXELS_PER_NEWTON = 0.5;
                const forceScale = force * PIXELS_PER_NEWTON;

                // Rita kraftvektorer
                const drawArrow = (fromX, fromY, toX, toY, color) => {
                    const headLen = 12;
                    const angle = Math.atan2(toY - fromY, toX - fromX);

                    // Glöd
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = color;

                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = 3;

                    // Linje
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    ctx.lineTo(toX, toY);
                    ctx.stroke();

                    // Pilhuvud
                    ctx.beginPath();
                    ctx.moveTo(toX, toY);
                    ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 0;
                };

                // Kraftvektorer för laddning 1
                // Rita endast om det finns en kraft och laddningarna inte överlappar
                if (charge1 !== 0 && charge2 !== 0 && dist > charge1Radius + charge2Radius && forceScale > 5) {
                    const f1DirX = isAttraction ? dirX : -dirX;
                    const f1DirY = isAttraction ? dirY : -dirY;
                    drawArrow(
                        pos1.x + f1DirX * (charge1Radius + 5),
                        pos1.y + f1DirY * (charge1Radius + 5),
                        pos1.x + f1DirX * (charge1Radius + 5 + forceScale),
                        pos1.y + f1DirY * (charge1Radius + 5 + forceScale),
                        '#fbbf24'
                    );

                    // Kraftvektor för laddning 2 (motsatt riktning)
                    const f2DirX = isAttraction ? -dirX : dirX;
                    const f2DirY = isAttraction ? -dirY : dirY;
                    drawArrow(
                        pos2.x + f2DirX * (charge2Radius + 5),
                        pos2.y + f2DirY * (charge2Radius + 5),
                        pos2.x + f2DirX * (charge2Radius + 5 + forceScale),
                        pos2.y + f2DirY * (charge2Radius + 5 + forceScale),
                        '#fbbf24'
                    );
                }

                // Rita laddning
                const drawCharge = (x, y, charge, radius, labelVar, labelValue) => {
                    const isPositive = charge > 0;
                    const color = isPositive ? '#ef4444' : '#38bdf8';
                    const glowColor = isPositive ? 'rgba(239, 68, 68, 0.6)' : 'rgba(56, 189, 248, 0.6)';

                    // Glöd
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = glowColor;

                    // Gradient för laddningen
                    const gradient = ctx.createRadialGradient(x - 10, y - 10, 5, x, y, radius);
                    gradient.addColorStop(0, isPositive ? '#fca5a5' : '#7dd3fc');
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, isPositive ? '#991b1b' : '#0369a1');

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.strokeStyle = isPositive ? '#fecaca' : '#bae6fd';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.shadowBlur = 0;

                    // Plus eller minus tecken - storlek anpassas efter radien
                    ctx.fillStyle = '#ffffff';
                    const fontSize = Math.max(16, Math.min(32, radius * 0.7));
                    ctx.font = `bold ${fontSize}px Poppins, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isPositive ? '+' : '−', x, y);

                    // Etikett - variabel i kursiv, värde i normal stil
                    ctx.textBaseline = 'top';

                    // Mät bredderna först
                    ctx.font = 'italic 18px Poppins, sans-serif';
                    const varWidth = ctx.measureText(labelVar).width;
                    ctx.font = '18px Poppins, sans-serif';
                    const eqValueWidth = ctx.measureText(' = ' + labelValue).width;
                    const totalWidth = varWidth + eqValueWidth;

                    // Centrera hela texten
                    const startX = x - totalWidth / 2;

                    // Variabel (kursiv)
                    ctx.fillStyle = isPositive ? '#fca5a5' : '#7dd3fc';
                    ctx.font = 'italic 18px Poppins, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(labelVar, startX, y + radius + 14);

                    // Värde (normal)
                    ctx.fillStyle = '#cbd5e1';
                    ctx.font = '18px Poppins, sans-serif';
                    ctx.fillText(' = ' + labelValue, startX + varWidth, y + radius + 14);
                };

                drawCharge(pos1.x, pos1.y, charge1, charge1Radius, 'Q₁', `${formatNumber(charge1, 1)} µC`);
                drawCharge(pos2.x, pos2.y, charge2, charge2Radius, 'Q₂', `${formatNumber(charge2, 1)} µC`);

                // Rita avståndslinje
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pos1.x, pos1.y);
                ctx.lineTo(pos2.x, pos2.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Avståndstext
                const midX = (pos1.x + pos2.x) / 2;
                const midY = (pos1.y + pos2.y) / 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const distCm = distance * 100;
                // Variabel r i kursiv
                ctx.fillStyle = '#a5b4fc';
                ctx.font = 'italic 17px Poppins, sans-serif';
                ctx.fillText('r', midX - 35, midY - 12);
                // Värde i normal stil
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '17px Poppins, sans-serif';
                ctx.fillText(` = ${formatNumber(distCm, 1)} cm`, midX + 5, midY - 12);

            }, [pos1, pos2, charge1, charge2, charge1Radius, charge2Radius, force, distance, canvasReady]);

            // Hantera resize
            useEffect(() => {
                const handleResize = () => {
                    if (containerRef.current && canvasRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        canvasRef.current.width = rect.width;
                        canvasRef.current.height = rect.height;
                        setCanvasReady(prev => !prev); // Trigga omritning
                    }
                };

                window.addEventListener('resize', handleResize);
                // Fördröj lite för att säkerställa att containern har rätt storlek
                setTimeout(handleResize, 50);
                setTimeout(handleResize, 200);

                return () => window.removeEventListener('resize', handleResize);
            }, []);

            return (
                <div className="dark-container min-h-screen">
                    <div className="max-w-6xl mx-auto py-8 px-4">
                        {/* Header */}
                        <header className="text-center mb-8">
                            <h1 className="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-cyan-400 tracking-tight glow-text mb-4">
                                Coulombs lag
                            </h1>
                            <p className="text-slate-400 max-w-2xl mx-auto leading-relaxed">
                                Utforska den elektriska kraften mellan två laddningar. Dra laddningarna för att ändra avståndet och använd glidarna för att justera laddningarnas storlek.
                            </p>
                        </header>

                        {/* Main layout: Simulation + Controls side by side */}
                        <div
                            ref={fullscreenRef}
                            className={`flex flex-col lg:flex-row gap-6 mb-6 ${isFullscreen ? 'bg-slate-950 p-6 h-screen' : ''}`}
                        >
                            {/* Simulation - left side */}
                            <div className={`glass-card rounded-2xl p-4 flex-grow lg:flex-grow-[2] relative ${isFullscreen ? 'h-full' : ''}`}>
                                {/* Fullscreen button */}
                                <button
                                    onClick={toggleFullscreen}
                                    className="absolute top-3 right-3 z-10 p-2 rounded-lg bg-slate-800/80 hover:bg-slate-700 text-slate-300 hover:text-white transition-colors"
                                    title={isFullscreen ? 'Avsluta fullskärm (Esc)' : 'Fullskärm'}
                                >
                                    {isFullscreen ? (
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    ) : (
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                                        </svg>
                                    )}
                                </button>
                                <div
                                    ref={containerRef}
                                    className={`relative w-full cursor-grab active:cursor-grabbing ${isFullscreen ? 'h-full' : ''}`}
                                    style={{ minHeight: isFullscreen ? '100%' : '400px' }}
                                >
                                    <canvas
                                        ref={canvasRef}
                                        className="block touch-none"
                                        style={{ width: '100%', height: '100%' }}
                                        onMouseDown={handleMouseDown}
                                        onMouseMove={handleMouseMove}
                                        onMouseUp={handleMouseUp}
                                        onMouseLeave={handleMouseUp}
                                        onTouchStart={handleTouchStart}
                                        onTouchMove={handleTouchMove}
                                        onTouchEnd={handleTouchEnd}
                                    />
                                </div>
                            </div>

                            {/* Controls - right side */}
                            <div className={`flex flex-col gap-4 lg:w-80 ${isFullscreen ? 'justify-center' : ''}`}>
                                {/* Charge 1 slider */}
                                <div className="glass-card-light p-4 rounded-xl">
                                    <h3 className="text-slate-200 font-semibold mb-3 flex items-center gap-2 text-sm">
                                        <span className="w-3 h-3 rounded-full bg-red-500"></span>
                                        Laddning Q₁
                                    </h3>
                                    <input
                                        type="range"
                                        min="-10"
                                        max="10"
                                        step="0.5"
                                        value={charge1}
                                        onChange={(e) => setCharge1(parseFloat(e.target.value))}
                                        className="w-full slider-custom"
                                    />
                                    <div className="flex justify-between text-xs text-slate-400 mt-2">
                                        <span>-10 µC</span>
                                        <span className={`font-semibold ${charge1 >= 0 ? 'text-red-400' : 'text-cyan-400'}`}>
                                            {formatNumber(charge1, 1)} µC
                                        </span>
                                        <span>+10 µC</span>
                                    </div>
                                </div>

                                {/* Charge 2 slider */}
                                <div className="glass-card-light p-4 rounded-xl">
                                    <h3 className="text-slate-200 font-semibold mb-3 flex items-center gap-2 text-sm">
                                        <span className="w-3 h-3 rounded-full bg-cyan-500"></span>
                                        Laddning Q₂
                                    </h3>
                                    <input
                                        type="range"
                                        min="-10"
                                        max="10"
                                        step="0.5"
                                        value={charge2}
                                        onChange={(e) => setCharge2(parseFloat(e.target.value))}
                                        className="w-full slider-custom"
                                    />
                                    <div className="flex justify-between text-xs text-slate-400 mt-2">
                                        <span>-10 µC</span>
                                        <span className={`font-semibold ${charge2 >= 0 ? 'text-red-400' : 'text-cyan-400'}`}>
                                            {formatNumber(charge2, 1)} µC
                                        </span>
                                        <span>+10 µC</span>
                                    </div>
                                </div>

                                {/* Force display */}
                                <div className="glass-card rounded-xl p-4 flex-grow">
                                    <h3 className="text-slate-200 font-semibold text-sm mb-2">Elektrisk kraft</h3>
                                    <p className="text-2xl font-bold text-amber-400 glow-text mb-1">
                                        F = {force < 0.01 ? formatScientific(force) : formatNumber(force, 3)} N
                                    </p>
                                    <p className="text-slate-400 text-xs mb-3">
                                        {(charge1 > 0 && charge2 < 0) || (charge1 < 0 && charge2 > 0)
                                            ? 'Attraktiv kraft (olika tecken)'
                                            : 'Repulsiv kraft (samma tecken)'}
                                    </p>
                                    {!isFullscreen && (
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={showCalculation}
                                                onChange={(e) => setShowCalculation(e.target.checked)}
                                                className="w-4 h-4 rounded border-slate-600 bg-slate-700 text-cyan-500 focus:ring-cyan-500 focus:ring-offset-slate-900"
                                            />
                                            <span className="text-slate-300 text-sm">Visa beräkning</span>
                                        </label>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Calculation display - full width below */}
                        {showCalculation && (
                            <div className="glass-card rounded-2xl p-6 mb-6">
                                <CalculationDisplay
                                    charge1={charge1}
                                    charge2={charge2}
                                    distance={distance}
                                    force={force}
                                    formatNumber={formatNumber}
                                />
                            </div>
                        )}

                        {/* Info cards */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-cyan-500/20 rounded-lg">
                                        <span className="text-cyan-400 text-xl font-bold">⚡</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Coulombs lag</h3>
                                        <p className="text-slate-400 text-sm">
                                            Beskriver kraften mellan två punktladdningar. Kraften är proportionell mot produkten av laddningarna och omvänt proportionell mot kvadraten på avståndet.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <div className="glass-card-light p-4 rounded-xl">
                                <div className="flex items-start gap-3">
                                    <div className="p-2 bg-amber-500/20 rounded-lg">
                                        <span className="text-amber-400 text-xl font-bold">↔</span>
                                    </div>
                                    <div>
                                        <h3 className="text-slate-200 font-semibold mb-1">Newtons tredje lag</h3>
                                        <p className="text-slate-400 text-sm">
                                            Krafterna är lika stora men motriktade. Båda laddningarna påverkar varandra med samma kraft, oavsett deras storlek.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<CoulombSimulation />);
    </script>
</body>
</html>
