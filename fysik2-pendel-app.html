<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan pendel - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Import map to resolve "three" -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>

    <style>
        body {
            font-family: 'Poppins', sans-serif;
        }

        .dark-container {
            background: linear-gradient(135deg, #0a0a1a 0%, #0d1526 50%, #0a1020 100%);
        }

        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.15);
        }

        .glow-text {
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #canvas-container canvas {
            display: block;
        }

        /* Slider styling - dark theme */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            height: 20px;
            cursor: pointer;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: rgba(148, 163, 184, 0.25);
            border-radius: 4px;
            height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #38bdf8;
            margin-top: -7px;
            cursor: pointer;
            transition: background 0.2s, box-shadow 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #7dd3fc;
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.5);
        }
        input[type="range"]::-moz-range-track {
            background: rgba(148, 163, 184, 0.25);
            border-radius: 4px;
            height: 6px;
            border: none;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            border: none;
            transition: background 0.2s, box-shadow 0.2s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #7dd3fc;
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.5);
        }
        input[type="range"]:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #475569;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-moz-range-thumb {
            background: #475569;
            cursor: not-allowed;
        }

        /* Canvas overlay buttons */
        .canvas-btn {
            padding: 0.5rem 1rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            border-radius: 0.5rem;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(8px);
            color: #e2e8f0;
            transition: all 0.2s;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        .canvas-btn:hover:not(:disabled) {
            background: rgba(30, 41, 59, 0.95);
            border-color: rgba(56, 189, 248, 0.35);
        }
        .canvas-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }
        .canvas-btn-orange {
            border-color: rgba(251, 146, 60, 0.35);
            color: #fb923c;
        }
        .canvas-btn-orange:hover:not(:disabled) {
            background: rgba(251, 146, 60, 0.12);
            border-color: rgba(251, 146, 60, 0.6);
        }
        .canvas-btn-red {
            border-color: rgba(248, 113, 113, 0.35);
            color: #f87171;
        }
        .canvas-btn-red:hover:not(:disabled) {
            background: rgba(248, 113, 113, 0.12);
            border-color: rgba(248, 113, 113, 0.6);
        }
        .canvas-btn-cyan {
            border-color: rgba(56, 189, 248, 0.35);
            color: #38bdf8;
        }
        .canvas-btn-cyan:hover:not(:disabled) {
            background: rgba(56, 189, 248, 0.12);
            border-color: rgba(56, 189, 248, 0.6);
        }
        .canvas-btn-yellow {
            border-color: rgba(234, 179, 8, 0.4);
            color: #eab308;
            cursor: not-allowed;
            opacity: 0.75;
        }
        .canvas-btn-green {
            border-color: rgba(74, 222, 128, 0.4);
            color: #4ade80;
            cursor: not-allowed;
            opacity: 0.85;
        }
    </style>
</head>
<body class="bg-slate-950">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link active">Fysik 2</a></li>
                <li><a href="om.html" class="nav-link">Om</a></li>
                <li><a href="kontakt.html" class="nav-link">Kontakt</a></li>
            </ul>
        </div>
    </nav>

    <main class="min-h-screen w-full dark-container text-slate-100 flex flex-col lg:flex-row">
        <div id="canvas-container" class="flex-grow min-h-[600px] w-full lg:w-1/2 relative" style="background: #0a0f1e;">
            <div class="absolute top-4 left-4 z-10 p-2">
                <div class="breadcrumb mb-2" style="font-size: 0.75rem;">
                    <a href="index.html">Hem</a> / <a href="fysik2.html">Fysik 2</a> / Plan pendel
                </div>
                <h1 class="text-2xl md:text-4xl font-bold tracking-tight" style="background: linear-gradient(90deg, #38bdf8, #7dd3fc, #38bdf8); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; filter: drop-shadow(0 0 20px rgba(56, 189, 248, 0.4));">Plan pendel (matematisk)</h1>
            </div>
            <div id="simulation-controls" class="absolute top-4 right-4 flex flex-col gap-3 z-10">
                <div class="flex gap-3">
                    <button id="canvas-pause-button" class="canvas-btn canvas-btn-orange" disabled>
                        ⏸ Pausa
                    </button>
                    <button id="canvas-abort-button" class="canvas-btn canvas-btn-red" disabled>
                        ⏹ Återställ
                    </button>
                </div>
                <button id="canvas-timing-button" class="canvas-btn canvas-btn-cyan" disabled>
                    ⏱ Ta tiden för 10 pendlingar
                </button>
            </div>
        </div>
        <div class="w-full lg:w-1/2 p-6 md:p-8 flex flex-col space-y-8 overflow-y-auto"
             id="controls-container"
             style="background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(12px); border-left: 1px solid rgba(56, 189, 248, 0.15);">
        </div>
    </main>

    <footer class="footer">
        <p>&copy; 2025 Fysiklabbet. Skapad av Sam Skoglund.</p>
    </footer>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const celestialBodies = [
            { name: 'Solen', gravity: 274.0, gradient: 'linear-gradient(45deg, #fef08a, #f97316)' },
            { name: 'Merkurius', gravity: 3.7, gradient: 'linear-gradient(45deg, #e5e5e5, #a3a3a3)' },
            { name: 'Venus', gravity: 8.87, gradient: 'linear-gradient(45deg, #fef3c7, #f59e0b)' },
            { name: 'Jorden', gravity: 9.81, gradient: 'linear-gradient(45deg, #22c55e, #3b82f6)' },
            { name: 'Månen', gravity: 1.62, gradient: 'linear-gradient(45deg, #f5f5f5, #a3a3a3)' },
            { name: 'Mars', gravity: 3.72, gradient: 'linear-gradient(45deg, #fb923c, #ef4444)' },
            { name: 'Jupiter', gravity: 24.79, gradient: 'linear-gradient(45deg, #fcd34d, #d97706, #f5f5f5)' },
            { name: 'Saturnus', gravity: 10.44, gradient: 'linear-gradient(45deg, #fde68a, #ca8a04)' },
            { name: 'Uranus', gravity: 8.69, gradient: 'linear-gradient(45deg, #7dd3fc, #0ea5e9)' },
            { name: 'Neptunus', gravity: 11.15, gradient: 'linear-gradient(45deg, #3b82f6, #1e3a8a)' },
        ];

        // State
        let params = {
            length: 1.5,
            gravity: 9.81,
            mass: 0.15,
            initialAngle: 0,
            damping: 0.05,
        };

        let simulationState = 'idle'; // 'idle', 'running', 'paused', 'finished'
        let timer = 0;
        let swingCount = 0;
        let measuredPeriod = null;
        let timeRef = 0;
        let swingCountRef = 0;
        let timingActive = false; // Whether we're actively timing 10 swings
        let timingStartTime = 0;
        let timingStartSwing = 0;
        let previousAngle = 0;
        let waitingForTurningPoint = false;

        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0f1e);

        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(0, 1.5, 5.0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights - adjusted for dark scene
        const ambientLight = new THREE.AmbientLight(0x8ab4d0, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xc8e0ff, 1.2);
        directionalLight.position.set(8, 6, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Subtle fill light from below/back for depth
        const fillLight = new THREE.DirectionalLight(0x1a3a5c, 0.4);
        fillLight.position.set(-4, -2, -3);
        scene.add(fillLight);

        // Floor - dark tile/concrete look
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x0d1a2e, roughness: 0.9, metalness: 0.05 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Lab stand
        const standMaterial = new THREE.MeshStandardMaterial({ color: 0x9ab4cc, metalness: 0.75, roughness: 0.25 });

        const VERTICAL_OFFSET = 1.0;
        const PIVOT_Z_OFFSET = 0.4;
        const verticalRodPositionX = -0.4;

        function createLabStand(pendulumLength) {
            const standGroup = new THREE.Group();
            const PIVOT_Y = pendulumLength + VERTICAL_OFFSET;
            const verticalRodHeight = PIVOT_Y + 0.5;

            // Base
            const baseGeometry = new THREE.BoxGeometry(1, 0.1, 1);
            const base = new THREE.Mesh(baseGeometry, standMaterial);
            base.position.set(verticalRodPositionX, -0.5 + 0.05, 0);
            base.castShadow = true;
            base.receiveShadow = true;
            standGroup.add(base);

            // Vertical rod
            const verticalRodGeometry = new THREE.CylinderGeometry(0.04, 0.04, verticalRodHeight, 16);
            const verticalRod = new THREE.Mesh(verticalRodGeometry, standMaterial);
            verticalRod.position.set(verticalRodPositionX, -0.5 + verticalRodHeight / 2, 0);
            verticalRod.castShadow = true;
            standGroup.add(verticalRod);

            // Clamp 1
            const clamp1Geometry = new THREE.BoxGeometry(0.12, 0.15, 0.12);
            const clamp1 = new THREE.Mesh(clamp1Geometry, standMaterial);
            clamp1.position.set(verticalRodPositionX, PIVOT_Y, 0);
            clamp1.castShadow = true;
            standGroup.add(clamp1);

            // Horizontal rod 1
            const horizontalRod1Geometry = new THREE.CylinderGeometry(0.04, 0.04, Math.abs(verticalRodPositionX), 16);
            const horizontalRod1 = new THREE.Mesh(horizontalRod1Geometry, standMaterial);
            horizontalRod1.position.set(verticalRodPositionX / 2, PIVOT_Y, 0);
            horizontalRod1.rotation.z = Math.PI / 2;
            horizontalRod1.castShadow = true;
            standGroup.add(horizontalRod1);

            // Clamp 2
            const clamp2Geometry = new THREE.BoxGeometry(0.12, 0.12, 0.15);
            const clamp2 = new THREE.Mesh(clamp2Geometry, standMaterial);
            clamp2.position.set(0, PIVOT_Y, 0);
            clamp2.castShadow = true;
            standGroup.add(clamp2);

            // Horizontal rod 2
            const horizontalRod2Geometry = new THREE.CylinderGeometry(0.04, 0.04, PIVOT_Z_OFFSET, 16);
            const horizontalRod2 = new THREE.Mesh(horizontalRod2Geometry, standMaterial);
            horizontalRod2.position.set(0, PIVOT_Y, PIVOT_Z_OFFSET / 2);
            horizontalRod2.rotation.x = Math.PI / 2;
            horizontalRod2.castShadow = true;
            standGroup.add(horizontalRod2);

            return standGroup;
        }

        let labStand = createLabStand(params.length);
        scene.add(labStand);

        // Pendulum
        const pendulumGroup = new THREE.Group();

        function createPendulum(length, mass) {
            // Clear existing pendulum
            while(pendulumGroup.children.length > 0) {
                pendulumGroup.remove(pendulumGroup.children[0]);
            }

            const PIVOT_Y = length + VERTICAL_OFFSET;
            pendulumGroup.position.set(0, PIVOT_Y, PIVOT_Z_OFFSET);

            // Pivot
            const pivotGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const pivotMaterial = new THREE.MeshStandardMaterial({ color: 0xb0c8e0, metalness: 0.6 });
            const pivot = new THREE.Mesh(pivotGeometry, pivotMaterial);
            pendulumGroup.add(pivot);

            // String
            const stringGeometry = new THREE.CylinderGeometry(0.01, 0.01, length, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xd0e4f0 });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -length / 2;
            string.castShadow = true;
            pendulumGroup.add(string);

            // Bob
            const bobRadius = 0.18 * Math.cbrt(mass);
            const bobHeight = bobRadius * 3.5;
            const bobGeometry = new THREE.CylinderGeometry(bobRadius, bobRadius, bobHeight, 32);
            const bobMaterial = new THREE.MeshStandardMaterial({ color: 0x90c0e0, metalness: 0.5, roughness: 0.3 });
            const bob = new THREE.Mesh(bobGeometry, bobMaterial);
            bob.position.y = -length - bobHeight / 2;
            bob.castShadow = true;
            pendulumGroup.add(bob);

            return bob;
        }

        const bob = createPendulum(params.length, params.mass);
        scene.add(pendulumGroup);

        // Visual aids for angle
        const angleVisualsGroup = new THREE.Group();
        scene.add(angleVisualsGroup);

        function updateAngleVisuals() {
            // Clear previous visuals
            while(angleVisualsGroup.children.length > 0) {
                angleVisualsGroup.remove(angleVisualsGroup.children[0]);
            }

            if (Math.abs(params.initialAngle) > 0.1 && simulationState === 'idle') {
                const PIVOT_Y = params.length + VERTICAL_OFFSET;

                // Dashed vertical line (plumb line)
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: 0x4a6a8a,
                    dashSize: 0.1,
                    gapSize: 0.05,
                });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, PIVOT_Y, PIVOT_Z_OFFSET),
                    new THREE.Vector3(0, PIVOT_Y - params.length - 0.3, PIVOT_Z_OFFSET)
                ]);
                const plumbLine = new THREE.Line(lineGeometry, lineMaterial);
                plumbLine.computeLineDistances();
                angleVisualsGroup.add(plumbLine);

                // Angle arc - from vertical line to pendulum string
                const angleRad = (params.initialAngle * Math.PI) / 180;
                const arcRadius = params.length * 0.25;
                const arcPoints = [];
                const steps = 20;

                // Arc goes from vertical (0) to the pendulum angle
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const angle = angleRad * t; // 0 to angleRad
                    arcPoints.push(new THREE.Vector3(
                        Math.sin(angle) * arcRadius,
                        PIVOT_Y - Math.cos(angle) * arcRadius,
                        PIVOT_Z_OFFSET
                    ));
                }

                const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
                const arcMaterial = new THREE.LineBasicMaterial({ color: 0x38bdf8, linewidth: 2 });
                const arc = new THREE.Line(arcGeometry, arcMaterial);
                angleVisualsGroup.add(arc);

                // Angle text using canvas texture
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = '#38bdf8';
                context.font = 'Bold 28px Poppins, Arial, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                const angleText = Math.round(params.initialAngle) + '°';
                context.fillText(angleText, 64, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);

                // Position text closer to arc and higher up
                const textAngle = angleRad / 2;
                const textRadius = arcRadius * 1.15;  // Closer to arc
                sprite.position.set(
                    Math.sin(textAngle) * textRadius,
                    PIVOT_Y - Math.cos(textAngle) * textRadius,  // Higher up
                    PIVOT_Z_OFFSET
                );
                sprite.scale.set(0.35, 0.175, 1);
                angleVisualsGroup.add(sprite);
            }
        }

        // Update camera target
        function updateCameraTarget() {
            const PIVOT_Y = params.length + VERTICAL_OFFSET;
            controls.target.set(0, PIVOT_Y - params.length / 2, 0);
            controls.update();
        }
        updateCameraTarget();

        // Mouse interaction for dragging pendulum
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (isDragging && simulationState === 'idle') {
                raycaster.setFromCamera(mouse, camera);

                // Calculate angle based on mouse position
                const pivotY = params.length + VERTICAL_OFFSET;
                const pivotPos = new THREE.Vector3(0, pivotY, PIVOT_Z_OFFSET);

                // Project mouse ray onto a plane at the pendulum's Z position
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -PIVOT_Z_OFFSET);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);

                if (intersection) {
                    // Calculate angle from pivot to intersection point
                    const dx = intersection.x - pivotPos.x;
                    const dy = intersection.y - pivotPos.y;
                    const angle = Math.atan2(dx, -dy); // Negative dy because y is up

                    // Limit angle to ±25 degrees
                    const angleDeg = (angle * 180) / Math.PI;
                    params.initialAngle = Math.max(-25, Math.min(25, angleDeg));

                    // Update slider position
                    const angleSlider = document.getElementById('angle-slider');
                    if (angleSlider) angleSlider.value = params.initialAngle;

                    updateAngleVisuals();
                    updateValueDisplays();
                }
            }
        }

        function onMouseDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (simulationState === 'idle') {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(bob, true);

                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false; // Disable orbit controls while dragging
                }
            }
        }

        function onMouseUp() {
            if (isDragging && params.initialAngle >= 0.5 && simulationState === 'idle') {
                // Auto-start simulation when releasing after drag
                simulationState = 'running';
                timer = 0;
                timeRef = 0;
                swingCount = 0;
                swingCountRef = 0;
                measuredPeriod = null;
                timingActive = false;
                waitingForTurningPoint = false;
                previousAngle = 0;
                updateAngleVisuals(); // Clear angle visuals when starting
                renderUI();
            }
            isDragging = false;
            controls.enabled = true;
        }

        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            if (simulationState === 'running') {
                const delta = 1/60;
                timeRef += delta;
                timer = timeRef;

                const initialAngleRad = (params.initialAngle * Math.PI) / 180;
                const omega = Math.sqrt(params.gravity / params.length);
                const angle = initialAngleRad * Math.exp(-params.damping * timeRef) * Math.cos(omega * timeRef);

                pendulumGroup.rotation.z = angle;

                // Detect turning points (angle changes sign)
                if (waitingForTurningPoint && previousAngle * angle < 0) {
                    // We've hit a turning point
                    waitingForTurningPoint = false;
                    timingActive = true;
                    timingStartTime = timeRef;
                    timingStartSwing = Math.floor((omega * timeRef) / (2 * Math.PI));
                    renderUI();
                }

                // Count swings if timing is active
                if (timingActive) {
                    const currentSwings = Math.floor((omega * timeRef) / (2 * Math.PI));
                    const swingsSinceTiming = currentSwings - timingStartSwing;

                    if (swingsSinceTiming >= 10) {
                        // Completed 10 swings
                        const elapsedTime = timeRef - timingStartTime;
                        measuredPeriod = elapsedTime / 10;
                        timingActive = false;
                        renderUI();
                    }
                }

                previousAngle = angle;
                renderUI();
            } else if (simulationState === 'paused') {
                // When paused, keep current angle - do nothing
            } else {
                const initialAngleRad = (params.initialAngle * Math.PI) / 180;
                pendulumGroup.rotation.z = initialAngleRad;
                updateAngleVisuals();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Controls UI - separated into render and event setup
        function renderUI() {
            const period = 2 * Math.PI * Math.sqrt(params.length / params.gravity);
            const isIdle = simulationState === 'idle';

            const controlsHTML = `
                <div class="space-y-6">
                    <h2 class="text-xl font-bold text-slate-100 pb-2" style="border-bottom: 2px solid rgba(56, 189, 248, 0.4);">Kontrollpanel</h2>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-slate-300' : 'text-slate-500'}">Trådlängd (<em>l</em>)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'text-cyan-300' : 'text-slate-500'}"
                                  style="${isIdle ? 'background: rgba(14, 165, 233, 0.12); border: 1px solid rgba(56, 189, 248, 0.2);' : 'background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.3);'}">
                                ${params.length.toFixed(2).replace('.', ',')} m
                            </span>
                        </div>
                        <input id="length-slider" type="range" min="0.5" max="5" step="0.1" value="${params.length}" ${!isIdle ? 'disabled' : ''}>
                    </div>

                    <div>
                        <div class="w-full">
                            <div class="flex justify-between items-center mb-1">
                                <label class="text-sm font-medium ${isIdle ? 'text-slate-300' : 'text-slate-500'}">Tyngdfaktor (<em>g</em>)</label>
                                <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'text-cyan-300' : 'text-slate-500'}"
                                      style="${isIdle ? 'background: rgba(14, 165, 233, 0.12); border: 1px solid rgba(56, 189, 248, 0.2);' : 'background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.3);'}">
                                    ${params.gravity.toFixed(2).replace('.', ',')} m/s²
                                </span>
                            </div>
                            <input id="gravity-slider" type="range" min="1" max="25" step="0.1" value="${params.gravity}" ${!isIdle ? 'disabled' : ''}>
                        </div>
                        <div class="mt-4">
                            <label class="text-sm font-medium mb-2 block ${isIdle ? 'text-slate-200' : 'text-slate-500'}">Eller välj en himlakropp:</label>
                            <div class="flex flex-wrap justify-center gap-3">
                                ${celestialBodies.map(body => {
                                    const isSelected = Math.abs(params.gravity - body.gravity) < 0.01;
                                    return `
                                        <div class="flex flex-col items-center">
                                            <button data-gravity="${body.gravity}" class="celestial-button p-1 rounded-full transition-all duration-200 focus:outline-none ${!isIdle ? 'opacity-40 cursor-not-allowed' : 'hover:scale-105'}"
                                                style="${isSelected
                                                    ? 'background: rgba(56, 189, 248, 0.15); box-shadow: 0 0 0 2px #38bdf8, 0 0 12px rgba(56, 189, 248, 0.3); outline-offset: 2px;'
                                                    : 'background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148, 163, 184, 0.15);;'}"
                                                ${!isIdle ? 'disabled' : ''} title="${body.name} (g = ${body.gravity.toFixed(2).replace('.', ',')} m/s²)">
                                                <div class="w-10 h-10 rounded-full" style="background-image: ${body.gradient}"></div>
                                            </button>
                                            <span class="text-xs mt-1 ${isIdle ? 'text-slate-200' : 'text-slate-500'}">${body.name}</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-slate-300' : 'text-slate-500'}">Massa (<em>m</em>)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'text-cyan-300' : 'text-slate-500'}"
                                  style="${isIdle ? 'background: rgba(14, 165, 233, 0.12); border: 1px solid rgba(56, 189, 248, 0.2);' : 'background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.3);'}">
                                ${(params.mass * 1000).toFixed(0)} g
                            </span>
                        </div>
                        <input id="mass-slider" type="range" min="10" max="300" step="5" value="${params.mass * 1000}" ${!isIdle ? 'disabled' : ''}>
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-slate-300' : 'text-slate-500'}">Startvinkel (<em>θ</em>)</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'text-cyan-300' : 'text-slate-500'}"
                                  style="${isIdle ? 'background: rgba(14, 165, 233, 0.12); border: 1px solid rgba(56, 189, 248, 0.2);' : 'background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.3);'}">
                                ${Math.round(params.initialAngle)}°
                            </span>
                        </div>
                        <input id="angle-slider" type="range" min="0" max="25" step="1" value="${params.initialAngle}" ${!isIdle ? 'disabled' : ''}>
                    </div>

                    <div class="w-full">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-sm font-medium ${isIdle ? 'text-slate-300' : 'text-slate-500'}">Dämpning</label>
                            <span class="text-sm font-mono px-2 py-0.5 rounded font-semibold ${isIdle ? 'text-cyan-300' : 'text-slate-500'}"
                                  style="${isIdle ? 'background: rgba(14, 165, 233, 0.12); border: 1px solid rgba(56, 189, 248, 0.2);' : 'background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.3);'}">
                                ${params.damping.toFixed(2).replace('.', ',')}
                            </span>
                        </div>
                        <input id="damping-slider" type="range" min="0" max="0.5" step="0.01" value="${params.damping}" ${!isIdle ? 'disabled' : ''}>
                    </div>

                    <div class="p-4 rounded-lg text-center space-y-2"
                         style="background: rgba(14, 165, 233, 0.08); border: 1px solid rgba(56, 189, 248, 0.2);">
                        <h3 class="text-lg font-semibold text-cyan-300">Mätning</h3>
                        ${simulationState === 'idle' ? '<p class="text-sm text-slate-300">Dra pendeln och släpp för att starta.</p>' : ''}
                        ${simulationState === 'running' && !waitingForTurningPoint && !timingActive ? '<p class="text-sm text-slate-300">Tryck på "Ta tiden" för att mäta perioden.</p>' : ''}
                        ${waitingForTurningPoint ? '<p class="text-sm font-semibold" style="color: #fb923c;">Väntar på nästa vändläge...</p>' : ''}
                        ${timingActive ? `
                            <div class="space-y-2">
                                <p class="text-sm font-semibold" style="color: #4ade80;">Tidtagning pågår!</p>
                                <div>
                                    <p class="text-sm text-slate-300">Svängningar sedan start</p>
                                    <p class="text-3xl font-mono font-bold text-slate-100">${Math.floor((Math.sqrt(params.gravity / params.length) * timeRef) / (2 * Math.PI)) - timingStartSwing} / 10</p>
                                </div>
                            </div>
                        ` : ''}
                        ${measuredPeriod !== null && !timingActive ? `
                            <div class="pt-3" style="border-top: 1px solid rgba(56, 189, 248, 0.2);">
                                <p class="text-sm text-slate-300">Uppmätt period (<em>T</em>)</p>
                                <p class="text-3xl font-mono font-bold" style="color: #4ade80;">${measuredPeriod.toFixed(3).replace('.', ',')} s</p>
                            </div>
                        ` : ''}
                    </div>

                    <div class="flex items-center justify-center space-x-4 pt-4">
                        <button id="start-button" ${!isIdle || params.initialAngle < 0.5 ? 'disabled' : ''}
                            class="px-6 py-2 font-semibold text-slate-900 rounded-lg transition-all duration-200 focus:outline-none w-32"
                            style="${!isIdle || params.initialAngle < 0.5
                                ? 'background: rgba(56, 189, 248, 0.25); color: rgba(148, 163, 184, 0.5); cursor: not-allowed; border: 1px solid rgba(56, 189, 248, 0.15);'
                                : 'background: linear-gradient(135deg, #38bdf8, #0ea5e9); color: #0f172a; cursor: pointer; border: none; box-shadow: 0 0 16px rgba(56, 189, 248, 0.3);'}">
                            Starta
                        </button>
                        <button id="reset-button"
                            class="px-6 py-2 font-semibold text-slate-300 rounded-lg transition-all duration-200 focus:outline-none w-32"
                            style="background: rgba(30, 41, 59, 0.7); border: 1px solid rgba(148, 163, 184, 0.2); cursor: pointer;">
                            Återställ
                        </button>
                    </div>
                </div>

                <div class="space-y-4 p-6 rounded-lg" style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(56, 189, 248, 0.12);">
                    <h2 class="text-xl font-bold text-slate-100 pb-2" style="border-bottom: 2px solid rgba(56, 189, 248, 0.4);">Information</h2>
                    <div class="text-center">
                        <p class="text-sm text-slate-300">Beräknad period (<em>T</em>)</p>
                        <p class="text-4xl font-mono font-bold my-2 period-display" style="color: #38bdf8; text-shadow: 0 0 12px rgba(56, 189, 248, 0.4);">${period.toFixed(3).replace('.', ',')} s</p>
                        <p class="text-sm font-mono text-slate-400">T = 2π · √(<em>l</em>/<em>g</em>)</p>
                    </div>
                    <div class="pt-4 text-sm text-slate-200 leading-relaxed space-y-2">
                        <p>
                            <strong style="color: #38bdf8;">Observera:</strong> Perioden – tiden för en komplett svängning fram och tillbaka – beror <strong class="font-semibold text-white">endast</strong> på pendelns <span style="color: #4ade80;">längd (<em>l</em>)</span> och den lokala <span style="color: #4ade80;">tyngdfaktorn (<em>g</em>)</span>.
                        </p>
                        <p>
                            Prova att ändra <span style="color: #f87171;">massan (<em>m</em>)</span> och <span style="color: #f87171;">startvinkeln (<em>θ</em>)</span>. Du kommer se att perioden förblir oförändrad. Detta är en fundamental egenskap hos en enkel pendel (för små vinklar).
                        </p>
                        <p>
                            <strong style="color: #38bdf8;">Dämpning</strong> simulerar luftmotstånd och gör att svängningarna gradvis minskar i storlek, precis som i verkligheten.
                        </p>
                    </div>
                </div>
            `;

            document.getElementById('controls-container').innerHTML = controlsHTML;

            // Update canvas control buttons
            const canvasPauseButton = document.getElementById('canvas-pause-button');
            const canvasAbortButton = document.getElementById('canvas-abort-button');
            const canvasTimingButton = document.getElementById('canvas-timing-button');

            if (canvasPauseButton && canvasAbortButton && canvasTimingButton) {
                if (simulationState === 'running' || simulationState === 'paused') {
                    // Active state - enabled
                    canvasPauseButton.disabled = false;
                    canvasAbortButton.disabled = false;
                    canvasPauseButton.className = 'canvas-btn canvas-btn-orange';
                    canvasAbortButton.className = 'canvas-btn canvas-btn-red';

                    // Update pause button text
                    if (simulationState === 'running') {
                        canvasPauseButton.textContent = '⏸ Pausa';
                    } else if (simulationState === 'paused') {
                        canvasPauseButton.textContent = '▶ Fortsätt';
                    }

                    // Timing button - enabled when running and not already timing
                    if (simulationState === 'running' && !waitingForTurningPoint && !timingActive) {
                        canvasTimingButton.disabled = false;
                        canvasTimingButton.className = 'canvas-btn canvas-btn-cyan';
                        canvasTimingButton.textContent = '⏱ Ta tiden för 10 pendlingar';
                    } else if (waitingForTurningPoint) {
                        canvasTimingButton.disabled = true;
                        canvasTimingButton.className = 'canvas-btn canvas-btn-yellow';
                        canvasTimingButton.textContent = '⏱ Väntar på vändläge...';
                    } else if (timingActive) {
                        canvasTimingButton.disabled = true;
                        canvasTimingButton.className = 'canvas-btn canvas-btn-green';
                        canvasTimingButton.textContent = '⏱ Tidtagning pågår...';
                    } else {
                        canvasTimingButton.disabled = true;
                        canvasTimingButton.className = 'canvas-btn canvas-btn-cyan';
                        canvasTimingButton.textContent = '⏱ Ta tiden för 10 pendlingar';
                    }
                } else {
                    // Inactive state - disabled
                    canvasPauseButton.disabled = true;
                    canvasAbortButton.disabled = true;
                    canvasTimingButton.disabled = true;
                    canvasPauseButton.className = 'canvas-btn canvas-btn-orange';
                    canvasAbortButton.className = 'canvas-btn canvas-btn-red';
                    canvasTimingButton.className = 'canvas-btn canvas-btn-cyan';
                    canvasPauseButton.textContent = '⏸ Pausa';
                    canvasTimingButton.textContent = '⏱ Ta tiden för 10 pendlingar';
                }
            }
        }

        // Fast value update - directly update DOM without re-rendering
        function updateValueDisplays() {
            const container = document.getElementById('controls-container');

            // Update all value displays
            const lengthDisplay = container.querySelector('#length-slider').parentElement.querySelector('span');
            if (lengthDisplay) lengthDisplay.textContent = params.length.toFixed(2).replace('.', ',') + ' m';

            const gravityDisplay = container.querySelector('#gravity-slider').parentElement.querySelector('span');
            if (gravityDisplay) gravityDisplay.textContent = params.gravity.toFixed(2).replace('.', ',') + ' m/s²';

            const massDisplay = container.querySelector('#mass-slider').parentElement.querySelector('span');
            if (massDisplay) massDisplay.textContent = (params.mass * 1000).toFixed(0) + ' g';

            const angleDisplay = container.querySelector('#angle-slider').parentElement.querySelector('span');
            if (angleDisplay) angleDisplay.textContent = Math.round(params.initialAngle) + '°';

            const dampingDisplay = container.querySelector('#damping-slider').parentElement.querySelector('span');
            if (dampingDisplay) dampingDisplay.textContent = params.damping.toFixed(2).replace('.', ',');

            // Update calculated period
            const period = 2 * Math.PI * Math.sqrt(params.length / params.gravity);
            const periodDisplay = container.querySelector('.period-display');
            if (periodDisplay) periodDisplay.textContent = period.toFixed(3).replace('.', ',') + ' s';
        }

        // Setup event listeners using event delegation - only runs once
        document.getElementById('controls-container').addEventListener('input', (e) => {
            if (e.target.id === 'length-slider') {
                params.length = parseFloat(e.target.value);
                scene.remove(labStand);
                labStand = createLabStand(params.length);
                scene.add(labStand);
                createPendulum(params.length, params.mass);
                updateCameraTarget();
                updateAngleVisuals();
                updateValueDisplays();
            } else if (e.target.id === 'gravity-slider') {
                params.gravity = parseFloat(e.target.value);
                updateValueDisplays();
            } else if (e.target.id === 'mass-slider') {
                params.mass = parseFloat(e.target.value) / 1000;
                createPendulum(params.length, params.mass);
                updateValueDisplays();
            } else if (e.target.id === 'angle-slider') {
                params.initialAngle = parseFloat(e.target.value);
                updateAngleVisuals();
                updateValueDisplays();
            } else if (e.target.id === 'damping-slider') {
                params.damping = parseFloat(e.target.value);
                updateValueDisplays();
            }
        });

        // Event listeners for canvas control buttons
        document.getElementById('canvas-pause-button').addEventListener('click', () => {
            if (simulationState === 'running') {
                simulationState = 'paused';
                renderUI();
            } else if (simulationState === 'paused') {
                simulationState = 'running';
                renderUI();
            }
        });

        document.getElementById('canvas-abort-button').addEventListener('click', () => {
            simulationState = 'idle';
            timer = 0;
            timeRef = 0;
            swingCount = 0;
            swingCountRef = 0;
            measuredPeriod = null;
            timingActive = false;
            waitingForTurningPoint = false;
            params.initialAngle = 0;
            updateAngleVisuals();
            renderUI();
        });

        document.getElementById('canvas-timing-button').addEventListener('click', () => {
            if (simulationState === 'running' && !waitingForTurningPoint && !timingActive) {
                // Start waiting for next turning point
                waitingForTurningPoint = true;
                measuredPeriod = null;
                renderUI();
            }
        });

        document.getElementById('controls-container').addEventListener('click', (e) => {
            if (e.target.id === 'start-button' || e.target.closest('#start-button')) {
                if (params.initialAngle >= 0.5 && simulationState === 'idle') {
                    simulationState = 'running';
                    timer = 0;
                    timeRef = 0;
                    swingCount = 0;
                    swingCountRef = 0;
                    measuredPeriod = null;
                    updateAngleVisuals(); // Clear angle visuals when starting
                    renderUI();
                }
            } else if (e.target.id === 'reset-button' || e.target.closest('#reset-button')) {
                simulationState = 'idle';
                timer = 0;
                timeRef = 0;
                swingCount = 0;
                swingCountRef = 0;
                measuredPeriod = null;
                params.initialAngle = 0;
                updateAngleVisuals();
                renderUI();
            } else if (e.target.closest('.celestial-button')) {
                const button = e.target.closest('.celestial-button');
                if (!button.disabled) {
                    params.gravity = parseFloat(button.dataset.gravity);
                    renderUI();
                }
            }
        });

        renderUI();
    </script>
</body>
</html>
