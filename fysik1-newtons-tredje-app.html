<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newtons tredje lag - Fysiklabbet</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-black overflow-hidden">
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">⚛️</span>
                <span class="logo-text">Fysiklabbet</span>
            </a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Hem</a></li>
                <li><a href="fysik1.html" class="nav-link active">Fysik 1</a></li>
                <li><a href="fysik2.html" class="nav-link">Fysik 2</a></li>
            </ul>
        </div>
    </nav>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // Types
        const THRUST_FORCE = 0.05;
        const PARTICLE_SPEED = 2;
        const PARTICLE_LIFESPAN = 60;
        const ASTRONAUT_RADIUS = 35;
        const ASTRONAUT_MASS = 1;
        const SATELLITE_MASS = 10;
        const SATELLITE_RADIUS = 100;

        const getInitialAstronautState = () => ({
          position: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
          velocity: { x: 0, y: 0 },
          rotation: 0,
          mass: ASTRONAUT_MASS,
          radius: ASTRONAUT_RADIUS,
        });

        // Starfield Component
        const Starfield = ({ starCount = 200 }) => {
          const stars = useMemo(() => {
            return Array.from({ length: starCount }).map((_, i) => ({
              id: i,
              x: `${Math.random() * 100}%`,
              y: `${Math.random() * 100}%`,
              size: `${Math.random() * 2 + 1}px`,
              opacity: `${Math.random() * 0.5 + 0.2}`,
            }));
          }, [starCount]);

          return (
            <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
              {stars.map((star) => (
                <div
                  key={star.id}
                  className="absolute bg-white rounded-full"
                  style={{
                    top: star.y,
                    left: star.x,
                    width: star.size,
                    height: star.size,
                    opacity: star.opacity,
                  }}
                />
              ))}
            </div>
          );
        };

        // Astronaut Component
        const Astronaut = ({ state }) => {
          return (
            <div
              className="absolute w-20 h-20"
              style={{
                left: state.position.x,
                top: state.position.y,
                transform: `translate(-50%, -50%) rotate(${state.rotation}deg)`,
                willChange: 'transform, top, left',
              }}
            >
              <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g>
                  <rect x="75" y="42" width="25" height="16" rx="4" fill="#E53E3E"/>
                  <rect x="98" y="47" width="7" height="6" fill="#A0AEC0"/>
                  <rect x="25" y="30" width="55" height="40" rx="20" fill="#EDF2F7"/>
                  <circle cx="28" cy="50" r="22" fill="#E2E8F0"/>
                  <circle cx="28" cy="50" r="16" fill="#2D3748"/>
                  <path d="M20 45 C 25 38, 35 38, 40 45" stroke="#718096" strokeWidth="2" strokeLinecap="round"/>
                  <rect x="55" y="25" width="20" height="50" rx="8" fill="#A0AEC0"/>
                  <rect x="35" y="70" width="15" height="20" rx="7.5" fill="#EDF2F7"/>
                  <rect x="55" y="70" width="15" height="20" rx="7.5" fill="#EDF2F7"/>
                  <rect x="35" y="10" width="15" height="20" rx="7.5" fill="#EDF2F7"/>
                  <rect x="55" y="10" width="15" height="20" rx="7.5" fill="#EDF2F7"/>
                </g>
              </svg>
            </div>
          );
        };

        // Satellite Component
        const Satellite = ({ state }) => {
          return (
            <div
              className="absolute"
              style={{
                left: state.position.x,
                top: state.position.y,
                width: '200px',
                height: '200px',
                transform: `translate(-50%, -50%) rotate(${state.rotation}deg)`,
                willChange: 'transform, top, left',
              }}
            >
              <svg viewBox="-40 -70 240 240" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g>
                  <path d="M0,0 L100,0 L100,25 L130,25 L130,65 L100,65 L100,90 L0,90 Z" fill="#9CA3AF" stroke="#6B7280" strokeWidth="2"/>
                  <rect x="100" y="25" width="30" height="40" fill="#111827" />
                  <circle cx="115" cy="45" r="15" fill="none" stroke="#FBBF24" strokeWidth="3" />
                  <circle cx="105" cy="20" r="2" fill="#F87171" />
                  <circle cx="130" cy="20" r="2" fill="#F87171" />
                  <circle cx="105" cy="70" r="2" fill="#F87171" />
                  <circle cx="130" cy="70" r="2" fill="#F87171" />
                  <rect x="10" y="10" width="80" height="15" rx="3" fill="#6B7280" />
                  <rect x="10" y="65" width="80" height="15" rx="3" fill="#6B7280" />
                  <circle cx="50" cy="45" r="12" fill="#6B7280" />
                  <rect x="30" y="-60" width="40" height="60" fill="#3B82F6" rx="4" />
                  <rect x="30" y="90" width="40" height="60" fill="#3B82F6" rx="4" />
                  <rect x="32" y="-58" width="36" height="56" fill="#60A5FA" rx="2" />
                  <rect x="32" y="92" width="36" height="56" fill="#60A5FA" rx="2" />
                </g>
              </svg>
            </div>
          );
        };

        // ForceVectors Component
        const ForceVectors = ({ isSpraying, astronautPosition, targetPosition }) => {
          if (!isSpraying) return null;

          const dx = targetPosition.x - astronautPosition.x;
          const dy = targetPosition.y - astronautPosition.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angleRad = Math.atan2(dy, dx);
          const angleDeg = angleRad * (180 / Math.PI);
          const length = Math.min(distance - 50, 150);

          if (length <= 0) return null;

          const vectorBaseStyle = {
            position: 'absolute',
            height: '4px',
            transformOrigin: 'left center',
          };

          const labelBaseStyle = {
            position: 'absolute',
            bottom: '8px',
            transform: 'translateX(-50%)',
            padding: '2px 6px',
            borderRadius: '4px',
            fontSize: '12px',
            fontWeight: 'bold',
            whiteSpace: 'nowrap',
          };

          return (
            <div className="absolute pointer-events-none" style={{ top: astronautPosition.y, left: astronautPosition.x, willChange: 'transform' }}>
              <div style={{ transform: `rotate(${angleDeg}deg)` }} className="absolute">
                <div style={{...vectorBaseStyle, left: '50px', width: `${length}px` }} className="bg-cyan-400 rounded-full">
                  <div style={{...labelBaseStyle, left: `${length / 2}px` }} className="bg-cyan-400 text-black">Aktion</div>
                  <div style={{ position: 'absolute', right: '-2px', top: '50%', transform: 'translateY(-50%)' }}
                    className="w-0 h-0 border-t-[6px] border-t-transparent border-b-[6px] border-b-transparent border-l-[10px] border-l-cyan-400" />
                </div>
              </div>
              <div style={{ transform: `rotate(${angleDeg + 180}deg)` }} className="absolute">
                <div style={{...vectorBaseStyle, left: '50px', width: `${length}px` }} className="bg-red-500 rounded-full">
                  <div style={{...labelBaseStyle, left: `${length / 2}px`}} className="bg-red-500 text-white">Reaktion</div>
                  <div style={{ position: 'absolute', right: '-2px', top: '50%', transform: 'translateY(-50%)' }}
                    className="w-0 h-0 border-t-[6px] border-t-transparent border-b-[6px] border-b-transparent border-l-[10px] border-l-red-500" />
                </div>
              </div>
            </div>
          );
        };

        // Main App
        const App = () => {
          const [astronaut, setAstronaut] = useState(getInitialAstronautState);
          const [satellite, setSatellite] = useState(null);
          const [particles, setParticles] = useState([]);
          const [isSpraying, setIsSpraying] = useState(false);
          const [showInstructions, setShowInstructions] = useState(true);
          const [isDocked, setIsDocked] = useState(false);
          const [showSoundMessage, setShowSoundMessage] = useState(false);

          const mousePosition = useRef({ x: 0, y: 0 });
          const animationFrameId = useRef();
          const particleIdCounter = useRef(0);

          const handleStartGame = () => {
            setShowInstructions(false);
            setIsDocked(false);

            const width = window.innerWidth;
            const height = window.innerHeight;
            const margin = 150;
            let x = Math.random() * (width - margin * 2) + margin;
            let y = Math.random() * (height - margin * 2) + margin;

            const distToCenter = Math.sqrt(Math.pow(x - width/2, 2) + Math.pow(y - height/2, 2));
            if (distToCenter < 300) {
                x = margin + 50;
                y = margin + 50;
            }

            setSatellite({
              position: { x, y },
              velocity: { x: 0, y: 0 },
              rotation: Math.random() * 360,
              mass: SATELLITE_MASS,
              radius: SATELLITE_RADIUS,
            });
          };

          const handleRestart = useCallback(() => {
            setAstronaut(getInitialAstronautState());
            setParticles([]);
            setSatellite(null);
            setShowInstructions(true);
            setIsSpraying(false);
            setIsDocked(false);
            setShowSoundMessage(false);
          }, []);

          const handleSoundClick = () => {
            setShowSoundMessage(true);
            setTimeout(() => setShowSoundMessage(false), 3000);
          };

          const handleMouseDown = useCallback((e) => {
            if (showInstructions) setShowInstructions(false);
            mousePosition.current = { x: e.clientX, y: e.clientY };
            setIsSpraying(true);
          }, [showInstructions]);

          const handleMouseUp = useCallback(() => setIsSpraying(false), []);
          const handleMouseMove = useCallback((e) => {
            mousePosition.current = { x: e.clientX, y: e.clientY };
          }, []);

          const handleTouchStart = useCallback((e) => {
            const target = e.target;
            if (target.closest('button')) return;
            e.preventDefault();
            if (showInstructions) setShowInstructions(false);
            if (e.touches.length > 0) {
              mousePosition.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
              setIsSpraying(true);
            }
          }, [showInstructions]);

          const handleTouchEnd = useCallback(() => setIsSpraying(false), []);

          const handleTouchMove = useCallback((e) => {
            if (isSpraying) {
              e.preventDefault();
              if (e.touches.length > 0) {
                mousePosition.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
              }
            }
          }, [isSpraying]);

          const gameLoop = useCallback(() => {
            if (isDocked) {
              animationFrameId.current = requestAnimationFrame(gameLoop);
              return;
            }

            let nextAstronaut = { ...astronaut };
            if (isSpraying) {
              const dx = mousePosition.current.x - nextAstronaut.position.x;
              const dy = mousePosition.current.y - nextAstronaut.position.y;
              const angleRad = Math.atan2(dy, dx);
              nextAstronaut.rotation = angleRad * (180 / Math.PI);

              const forceX = Math.cos(angleRad) * THRUST_FORCE;
              const forceY = Math.sin(angleRad) * THRUST_FORCE;

              nextAstronaut.velocity = {
                x: nextAstronaut.velocity.x - forceX,
                y: nextAstronaut.velocity.y - forceY
              };
            }

            let nextSatellite = satellite ? { ...satellite } : null;

            if (nextSatellite) {
              const dx = nextAstronaut.position.x - nextSatellite.position.x;
              const dy = nextAstronaut.position.y - nextSatellite.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < nextAstronaut.radius + nextSatellite.radius) {
                const satAngleRad = nextSatellite.rotation * (Math.PI / 180);
                const cos = Math.cos(-satAngleRad);
                const sin = Math.sin(-satAngleRad);

                const localAstroPos = {
                    x: cos * dx - sin * dy,
                    y: sin * dx + cos * dy
                };

                const SVG_CENTER_OFFSET = { x: 80, y: 50 };
                const localAstroPos_svg = {
                    x: localAstroPos.x + SVG_CENTER_OFFSET.x,
                    y: localAstroPos.y + SVG_CENTER_OFFSET.y,
                };

                const DOCKING_BAY_START_X = 100;
                const DOCKING_BAY_OPEN_Y = 25;
                const DOCKING_BAY_HEIGHT = 40;
                const DOCKING_BAY_DEPTH = 35;

                const isInsideDockingBay =
                    localAstroPos_svg.x >= DOCKING_BAY_START_X &&
                    localAstroPos_svg.x <= DOCKING_BAY_START_X + DOCKING_BAY_DEPTH &&
                    localAstroPos_svg.y >= DOCKING_BAY_OPEN_Y &&
                    localAstroPos_svg.y <= DOCKING_BAY_OPEN_Y + DOCKING_BAY_HEIGHT;

                const astroSpeed = Math.sqrt(nextAstronaut.velocity.x**2 + nextAstronaut.velocity.y**2);

                if (isInsideDockingBay && astroSpeed < 2.0) {
                    setIsDocked(true);
                } else if (!isInsideDockingBay) {
                    const collisionBoxes = [
                        { x: 0, y: 0, width: 100, height: 25 },
                        { x: 0, y: 65, width: 100, height: 25 },
                        { x: 0, y: 25, width: 85, height: 40 },
                    ];

                    for (const box of collisionBoxes) {
                        const closestX = Math.max(box.x, Math.min(localAstroPos_svg.x, box.x + box.width));
                        const closestY = Math.max(box.y, Math.min(localAstroPos_svg.y, box.y + box.height));

                        const distToClosest = Math.sqrt(
                            (localAstroPos_svg.x - closestX)**2 + (localAstroPos_svg.y - closestY)**2
                        );

                        if (distToClosest < nextAstronaut.radius) {
                            let localNormal = {
                                x: localAstroPos_svg.x - closestX,
                                y: localAstroPos_svg.y - closestY,
                            };
                            const mag = Math.sqrt(localNormal.x**2 + localNormal.y**2);
                            if (mag > 0) {
                                localNormal.x /= mag;
                                localNormal.y /= mag;
                            } else {
                                const dx1 = localAstroPos_svg.x - box.x;
                                const dx2 = (box.x + box.width) - localAstroPos_svg.x;
                                const dy1 = localAstroPos_svg.y - box.y;
                                const dy2 = (box.y + box.height) - localAstroPos_svg.y;
                                const min_d = Math.min(dx1, dx2, dy1, dy2);
                                if (min_d === dx1) localNormal = { x: -1, y: 0 };
                                else if (min_d === dx2) localNormal = { x: 1, y: 0 };
                                else if (min_d === dy1) localNormal = { x: 0, y: -1 };
                                else localNormal = { x: 0, y: 1 };
                            }

                            const worldNormal = {
                                x: Math.cos(satAngleRad) * localNormal.x - Math.sin(satAngleRad) * localNormal.y,
                                y: Math.sin(satAngleRad) * localNormal.x + Math.cos(satAngleRad) * localNormal.y,
                            };

                            const normal = worldNormal;
                            const tangent = { x: -normal.y, y: normal.x };

                            const dpTanA = nextAstronaut.velocity.x * tangent.x + nextAstronaut.velocity.y * tangent.y;
                            const dpTanS = nextSatellite.velocity.x * tangent.x + nextSatellite.velocity.y * tangent.y;
                            const dpNormA = nextAstronaut.velocity.x * normal.x + nextAstronaut.velocity.y * normal.y;
                            const dpNormS = nextSatellite.velocity.x * normal.x + nextSatellite.velocity.y * normal.y;

                            const m1 = (dpNormA * (nextAstronaut.mass - nextSatellite.mass) + 2 * nextSatellite.mass * dpNormS) / (nextAstronaut.mass + nextSatellite.mass);
                            const m2 = (dpNormS * (nextSatellite.mass - nextAstronaut.mass) + 2 * nextAstronaut.mass * dpNormA) / (nextAstronaut.mass + nextSatellite.mass);

                            nextAstronaut.velocity = {
                                x: tangent.x * dpTanA + normal.x * m1,
                                y: tangent.y * dpTanA + normal.y * m1
                            };
                            nextSatellite.velocity = {
                                x: tangent.x * dpTanS + normal.x * m2,
                                y: tangent.y * dpTanS + normal.y * m2
                            };

                            const overlap = nextAstronaut.radius - distToClosest;
                            nextAstronaut.position.x += worldNormal.x * overlap;
                            nextAstronaut.position.y += worldNormal.y * overlap;

                            break;
                        }
                    }
                }
              }
            }

            nextAstronaut.position = {
              x: nextAstronaut.position.x + nextAstronaut.velocity.x,
              y: nextAstronaut.position.y + nextAstronaut.velocity.y,
            };
            if (nextSatellite) {
              nextSatellite.position = {
                x: nextSatellite.position.x + nextSatellite.velocity.x,
                y: nextSatellite.position.y + nextSatellite.velocity.y,
              };
            }

            if (nextAstronaut.position.x < -40) nextAstronaut.position.x = window.innerWidth + 40;
            if (nextAstronaut.position.x > window.innerWidth + 40) nextAstronaut.position.x = -40;
            if (nextAstronaut.position.y < -40) nextAstronaut.position.y = window.innerHeight + 40;
            if (nextAstronaut.position.y > window.innerHeight + 40) nextAstronaut.position.y = -40;

            if (nextSatellite) {
              const satelliteBuffer = 120;
              if (nextSatellite.position.x < -satelliteBuffer) nextSatellite.position.x = window.innerWidth + satelliteBuffer;
              if (nextSatellite.position.x > window.innerWidth + satelliteBuffer) nextSatellite.position.x = -satelliteBuffer;
              if (nextSatellite.position.y < -satelliteBuffer) nextSatellite.position.y = window.innerHeight + satelliteBuffer;
              if (nextSatellite.position.y > window.innerHeight + satelliteBuffer) nextSatellite.position.y = -satelliteBuffer;
            }

            setAstronaut(nextAstronaut);
            setSatellite(nextSatellite);

            setParticles((prev) => {
              let newParticles = prev.map((p) => ({...p, life: p.life - 1, opacity: p.life / PARTICLE_LIFESPAN, position: { x: p.position.x + p.velocity.x, y: p.position.y + p.velocity.y }})).filter((p) => p.life > 0);
              if (isSpraying) {
                const angleRad = astronaut.rotation * (Math.PI / 180);
                const nozzleOffsetX = Math.cos(angleRad) * 50;
                const nozzleOffsetY = Math.sin(angleRad) * 50;
                const startPos = { x: astronaut.position.x + nozzleOffsetX, y: astronaut.position.y + nozzleOffsetY };
                const sprayAngle = Math.atan2(mousePosition.current.y - astronaut.position.y, mousePosition.current.x - astronaut.position.x);

                for (let i = 0; i < 3; i++) {
                  const spread = (Math.random() - 0.5) * 0.5;
                  const speed = PARTICLE_SPEED * (Math.random() * 0.5 + 0.75);
                  const vel = { x: Math.cos(sprayAngle + spread) * speed, y: Math.sin(sprayAngle + spread) * speed };
                  newParticles.push({ id: particleIdCounter.current++, position: startPos, velocity: vel, size: Math.random() * 3 + 2, opacity: 1, life: PARTICLE_LIFESPAN });
                }
              }
              return newParticles;
            });

            animationFrameId.current = requestAnimationFrame(gameLoop);
          }, [astronaut, satellite, isSpraying, isDocked]);

          useEffect(() => {
            animationFrameId.current = requestAnimationFrame(gameLoop);
            return () => {
              if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
              }
            };
          }, [gameLoop]);

          return (
            <div
              className="w-screen h-screen bg-gray-900 cursor-crosshair touch-none"
              onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseMove={handleMouseMove} onMouseLeave={handleMouseUp}
              onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchMove={handleTouchMove} onTouchCancel={handleTouchEnd}
            >
              <Starfield />

              <div className="absolute top-28 left-4 z-50 flex flex-col gap-2">
                {!satellite && (
                  <button onClick={handleStartGame} className="px-4 py-2 bg-cyan-500 text-black font-bold rounded-lg shadow-lg hover:bg-cyan-400 transition-colors">
                    Spelläge
                  </button>
                )}
                {(satellite || !showInstructions) && <button onClick={handleRestart} className="px-4 py-2 bg-red-500 text-white font-bold rounded-lg shadow-lg hover:bg-red-400 transition-colors">
                    Omstart
                </button>}
              </div>

              <button onClick={handleSoundClick} className="absolute top-28 right-4 z-50 w-14 h-14 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-full flex items-center justify-center transition-colors shadow-lg">
                <svg viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-8 h-8">
                  <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                  <line x1="23" y1="9" x2="17" y2="15"></line>
                  <line x1="17" y1="9" x2="23" y2="15"></line>
                </svg>
              </button>

              {showInstructions && (
                <div className="absolute top-1/4 left-1/2 -translate-x-1/2 text-white text-center text-xl md:text-2xl p-4 bg-black bg-opacity-50 rounded-lg animate-pulse w-11/12 md:w-auto">
                  <h1 className="font-bold text-3xl md:text-4xl mb-2 text-cyan-300">Newtons tredje lag</h1>
                  <p>Klicka/tryck och håll för att använda brandsläckaren.</p>
                  <p>Eller starta spelläget för en utmaning!</p>
                </div>
              )}

              {satellite && !showInstructions && !isDocked && (
                 <div className="absolute top-24 left-1/2 -translate-x-1/2 text-white text-center text-xl p-2 bg-black bg-opacity-50 rounded-lg w-11/12 md:w-auto">
                  <p>Navigera till den gula dockningsporten!</p>
                </div>
              )}

              {isDocked && (
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-center text-4xl p-8 bg-green-600 bg-opacity-80 rounded-xl shadow-2xl">
                  <h2 className="font-bold">Grattis!</h2>
                  <p className="text-xl mt-2">Du är i trygghet!</p>
                </div>
              )}

              {showSoundMessage && (
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-center text-2xl md:text-4xl p-8 bg-red-600 bg-opacity-90 rounded-xl shadow-2xl border-4 border-red-400 animate-pulse">
                  <h2 className="font-bold">I rymden kan ingen höra dig skrika.</h2>
                </div>
              )}

              {particles.map((p) => (
                <div key={p.id} className="absolute bg-gray-200 rounded-full" style={{ left: p.position.x, top: p.position.y, width: `${p.size}px`, height: `${p.size}px`, opacity: p.opacity, transform: 'translate(-50%, -50%)' }} />
              ))}

              <Astronaut state={astronaut} />
              {satellite && <Satellite state={satellite} />}

              <ForceVectors isSpraying={isSpraying} astronautPosition={astronaut.position} targetPosition={mousePosition.current} />
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
